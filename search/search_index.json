{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ScanPyImports","text":"<p>ScanPyImports scans directories for import statements in Python scripts and Jupyter notebooks, providing tools to summarize and visualize the import statements across your projects.</p> Cloud plot Spiral plot"},{"location":"#features","title":"Features","text":"<ul> <li>Directory Scanning:<ul> <li>Recursively scans directories to locate all Python files (<code>.py</code>) and Jupyter notebooks (<code>.ipynb</code>), collecting import statements from the code.</li> <li>Employs a set of regular expressions to find and parse import statements within the scripts.</li> </ul> </li> <li>Import Statement Data:<ul> <li>Organizes import data using DataFrames and conducts basic analyses.</li> </ul> </li> <li>Data Visualization:<ul> <li>Provides tools to visualize import data with various plotting options.</li> <li>Currently includes spiral plots and word clouds of the import statements.</li> </ul> </li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#dependencies","title":"Dependencies","text":"<p>ScanPyImports requires the following packages:</p> <ul> <li>pandas </li> <li>matplotlib  </li> <li>numpy  </li> <li>wordcloud </li> <li>pillow  </li> <li>nbformat </li> </ul>"},{"location":"#clone-or-download-scanpyimports","title":"Clone or download ScanPyImports","text":"<p>You can either:</p> <ul> <li> <p>download the source code here.  </p> </li> <li> <p>or clone the repo: <code>git clone https://github.com/lennon-c/ScanPyImports.git</code></p> </li> </ul>"},{"location":"#demos-tutorials","title":"Demos, Tutorials","text":"<ul> <li> <p>Data</p> <ul> <li>Data         Getting the DataFrame of your imported modules.</li> </ul> </li> <li> <p>Vizualization</p> <ul> <li>Visualizing Imported Modules</li> <li>Visualizing Any Data</li> </ul> </li> <li> <p>Viz. Customization</p> <ul> <li>Basics</li> <li>Masks for Cloud plots</li> <li>More Complex Visualizations </li> </ul> </li> </ul>"},{"location":"#api","title":"API","text":"<p>ScanPyImports</p>"},{"location":"#ScanPyImports","title":"<code>ScanPyImports</code>","text":"<p>ScanPyImports is a Python package designed to scan, track, and analyze import statements across Python files and Jupyter notebooks.</p> <p>Modules:</p> <ul> <li> <code>scan</code>           \u2013            <p>Handles directory scanning and the parsing of Python scripts and notebooks.</p> </li> <li> <code>analyzer</code>           \u2013            <p>Structures the parsed data into DataFrames and performs basic data cleaning and analysis.</p> </li> <li> <code>plotter</code>           \u2013            <p>Manages visualization tools.</p> </li> </ul> <p>The core of the package uses a set of regular expressions to parse import statements.</p> <p>      Yep! super Re. Attribution: xkcd.com </p>"},{"location":"Api/ScanPyImports/","title":"ScanPyImports","text":""},{"location":"Api/ScanPyImports/#ScanPyImports","title":"<code>ScanPyImports</code>","text":"<p>ScanPyImports is a Python package designed to scan, track, and analyze import statements across Python files and Jupyter notebooks.</p> <p>Modules:</p> <ul> <li> <code>scan</code>           \u2013            <p>Handles directory scanning and the parsing of Python scripts and notebooks.</p> </li> <li> <code>analyzer</code>           \u2013            <p>Structures the parsed data into DataFrames and performs basic data cleaning and analysis.</p> </li> <li> <code>plotter</code>           \u2013            <p>Manages visualization tools.</p> </li> </ul> <p>The core of the package uses a set of regular expressions to parse import statements.</p> <p>      Yep! super Re. Attribution: xkcd.com </p>"},{"location":"Api/analyzer/","title":"Analyzer","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer","title":"<code>ScanPyImports.analyzer</code>","text":"<p>A module for processing and analyzing data on imported modules. </p> <p>Classes:</p> <ul> <li> <code>Data</code>           \u2013            <p>Construct the base DataFrame of the import statement data.</p> </li> <li> <code>DataAnalyzer</code>           \u2013            <p>Processe and analyze the data on imported modules.</p> </li> </ul>"},{"location":"Api/analyzer/#ScanPyImports.analyzer-classes","title":"Classes","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data","title":"<code>Data(path)</code>","text":"<p>Construct the base DataFrame of the import statement data.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> </ul> Source code in <code>ScanPyImports/analyzer.py</code> <pre><code>def __init__(self, path: str) -&gt; None:\n    \"\"\"\n    Initialize a Data object with the given path.\n\n    Args:\n        path: Path to the directory.\n    \"\"\"\n    self.path = path\n    self.directory = Directory(path)\n\n    if not self.directory.exists:\n        raise ValueError(\"The provided directory path does not exist. Try another path!\")\n\n    self._df: Optional[pd.DataFrame] = None\n\n    # Documentation\n    self.path: str\n    \"\"\"Path to the directory.\"\"\"\n    self.directory: Directory \n    \"\"\"An instance of [Directory][ScanPyImports.scan.Directory] initiated with the given path.\"\"\"\n\n\n    super().__init__()\n</code></pre>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data-attributes","title":"Attributes","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>Path to the directory.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data.directory","title":"<code>directory: Directory</code>  <code>instance-attribute</code>","text":"<p>An instance of Directory initiated with the given path.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data.df","title":"<code>df: Optional[pd.DataFrame]</code>  <code>property</code>","text":"<p>DataFrame containing import data or None if the directory does not exist.</p> DataFrame content <p>The DataFrame contains the following columns: </p> <ul> <li><code>imported_0</code>, <code>imported_1</code>, ...     representing the imported  packages and modules.<ul> <li>where <code>imported_0</code> represents the top-level package or library being imported.</li> <li><code>imported_1</code> represents the module or submodule within the package being imported.</li> <li>and so on <code>imported_2</code> represent further nested modules, submodules if present in the import statement.</li> </ul> </li> <li><code>original</code>: The original line of text containing the import statement.</li> <li><code>alias</code>: Alias (if any) of the submodule.</li> <li><code>path</code>: Full path of the file containing the import.</li> <li><code>file</code>: File name.</li> <li><code>filename</code>: File name without extension.</li> <li><code>extension</code>: File extension.</li> <li><code>directory</code>: Directory path of the file.</li> </ul> <p>The data creation takes place in this private method. One could modify this code to retreive a dictionary or a JSON file instead of a DataFrame.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.Data-functions","title":"Functions","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer","title":"<code>DataAnalyzer(path, to_exclude=None)</code>","text":"<p>               Bases: <code>Data</code></p> <p>A class to process the data on imported modules.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>to_exclude</code>               (<code>List[str]</code>, default:                   <code>None</code> )           \u2013            <p>List of packages' names to exclude from the analysis.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_frequencies</code>             \u2013              <p>Return frequency of imported modules.</p> </li> </ul> Source code in <code>ScanPyImports/analyzer.py</code> <pre><code>def __init__(self, path: str, to_exclude : List[str] = None) -&gt; None:\n    \"\"\"Initiate DataAnalyzer\n\n    Args:\n        path: Path to the directory.\n        to_exclude: List of packages' names to exclude from the analysis.\n\n    methods: \n        get_frequencies: Return frequency of imported modules.\n\n    \"\"\"        \n    super().__init__(path)\n    self._clean_df = None\n    self._own_processed_df = None\n    self.to_exclude= to_exclude if to_exclude else []\n\n    # Documentation\n    self.to_exclude: List[str]\n    \"\"\"List of packages' names to exclude from the analysis.\"\"\" \n</code></pre>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer-attributes","title":"Attributes","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>Path to the directory.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.directory","title":"<code>directory: Directory</code>  <code>instance-attribute</code>","text":"<p>An instance of Directory initiated with the given path.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.df","title":"<code>df: Optional[pd.DataFrame]</code>  <code>property</code>","text":"<p>DataFrame containing import data or None if the directory does not exist.</p> DataFrame content <p>The DataFrame contains the following columns: </p> <ul> <li><code>imported_0</code>, <code>imported_1</code>, ...     representing the imported  packages and modules.<ul> <li>where <code>imported_0</code> represents the top-level package or library being imported.</li> <li><code>imported_1</code> represents the module or submodule within the package being imported.</li> <li>and so on <code>imported_2</code> represent further nested modules, submodules if present in the import statement.</li> </ul> </li> <li><code>original</code>: The original line of text containing the import statement.</li> <li><code>alias</code>: Alias (if any) of the submodule.</li> <li><code>path</code>: Full path of the file containing the import.</li> <li><code>file</code>: File name.</li> <li><code>filename</code>: File name without extension.</li> <li><code>extension</code>: File extension.</li> <li><code>directory</code>: Directory path of the file.</li> </ul> <p>The data creation takes place in this private method. One could modify this code to retreive a dictionary or a JSON file instead of a DataFrame.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.to_exclude","title":"<code>to_exclude: List[str]</code>  <code>instance-attribute</code>","text":"<p>List of packages' names to exclude from the analysis.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.clean_df","title":"<code>clean_df: pd.DataFrame</code>  <code>property</code>","text":"<p>A cleaned copy of df after conducting some minor changes.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.own_processed_df","title":"<code>own_processed_df: pd.DataFrame</code>  <code>property</code>","text":"<p>A copy of the DataFrame (df) after processing own-created modules.</p> Own-created modules <p>Own-created modules are defined as Python scripts that are imported as modules and reside in the same folder as the script containing the import statement.</p> <p>A natural extension would be to also include own-created packages residing in the same folder as the .py or .ipynb file where the import statment resides.</p> <p>In the returned DataFrame, own-created modules are dropped and replaced by the import statements residing inside the own-created module script, provided they relate to external libraries.</p>"},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer-functions","title":"Functions","text":""},{"location":"Api/analyzer/#ScanPyImports.analyzer.DataAnalyzer.get_frequencies","title":"<code>get_frequencies(exclude=True, process_own_modules=True)</code>","text":"<p>Get the frequency of imported modules.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to exclude the packages listed in to_exclude.</p> </li> <li> <code>process_own_modules</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to process own-created modules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>pd.Series: Series of import frequencies sorted in descending order.</p> </li> </ul> Source code in <code>ScanPyImports/analyzer.py</code> <pre><code>def get_frequencies(self, exclude: bool = True, process_own_modules: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Get the frequency of imported modules.\n\n    Args:\n        exclude: Whether to exclude the packages listed in [to_exclude][ScanPyImports.analyzer.DataAnalyzer.to_exclude].\n        process_own_modules: Whether to process own-created modules.\n\n    Returns:\n        pd.Series: Series of import frequencies sorted in descending order.\n    \"\"\"\n    df = self.own_processed_df if process_own_modules else self.clean_df\n    count_series = (df.groupby('imported_0')\n                    .size()\n                    .sort_values(ascending=False))\n\n    count_series.index.name = 'Imports'\n\n    if exclude:\n        count_series = count_series[~count_series.index.isin(self.to_exclude)]\n\n    return count_series\n</code></pre>"},{"location":"Api/create_df/","title":"Private method: _create_df","text":""},{"location":"Api/create_df/#ScanPyImports.analyzer.DataAnalyzer._create_df","title":"<code>ScanPyImports.analyzer.DataAnalyzer._create_df()</code>","text":"<p>Create a DataFrame with the data on imported modules.</p> <p>Returns:</p> <ul> <li> <code>Optional[DataFrame]</code>           \u2013            <p>DataFrame with import data or None if the directory does not exist.</p> </li> </ul> Source code in <code>ScanPyImports/analyzer.py</code> <pre><code>def _create_df(self) -&gt; Optional[pd.DataFrame]:\n    \"\"\"\n    Create a DataFrame with the data on imported modules.\n\n    Returns:\n        DataFrame with import data or None if the directory does not exist.\n    \"\"\"\n    if not self.directory.exists:\n        return None\n\n    data_frames = []\n    for file in self.directory.files:\n        if not file.has_imports:\n            continue\n\n        file_data_frames = []\n        for line in file.lines:\n            line_df = pd.DataFrame(line.imports)\n            line_df[\"alias\"] = line.alias\n            # line_df[\"alias\"] = pd.Series(line.alias)\n            line_df[\"original\"] = line.original\n\n            file_data_frames.append(line_df)\n\n        file_df = pd.concat(file_data_frames, ignore_index=True)\n        file_df['path'] = file.file\n        file_df['extension'] = file.extension\n        file_df['file'] = os.path.basename(file.file)\n        file_df['filename'] = os.path.basename(file.file).split('.')[0]\n        file_df['directory'] = os.path.dirname(file.file)\n        data_frames.append(file_df)\n\n    if not data_frames:\n        return None\n\n    directory_df = pd.concat(data_frames, ignore_index=True)\n\n    cols = list(directory_df.columns)\n    cols.sort( key= lambda c: str(c) )\n    directory_df = directory_df[cols].rename(columns=lambda col: \n                                       f'imported_{col}' \n                                       if isinstance(col, int) else col)\n\n    return directory_df\n</code></pre>"},{"location":"Api/plotter/","title":"Plotter","text":""},{"location":"Api/plotter/#ScanPyImports.plotter","title":"<code>ScanPyImports.plotter</code>","text":"<p>A module for generating visual representations of data using spiral plots and word clouds.</p> <p>Classes:</p> <ul> <li> <code>PlotSettings</code>           \u2013            <p>Manages plot settings, including defaults for spiral plots and WordCloud generation.</p> </li> <li> <code>Spiral</code>           \u2013            <p>Generates spiral bar plots using given settings.</p> </li> <li> <code>Cloud</code>           \u2013            <p>Generates word cloud plots using given settings.</p> </li> <li> <code>DataPlotter</code>           \u2013            <p>Extends DataAnalyzer to provide methods for visualizing data on imported modules.</p> </li> </ul> <p>The module also includes utility functions to obtain the current file directory and load image masks.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter-classes","title":"Classes","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings","title":"<code>PlotSettings()</code>","text":"<p>A class to manage plot settings, including defaults for spiral plots and WordCloud generation.</p> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize PlotSettings with default values.\"\"\"\n    self.fontpath: str = None\n    \"\"\"Path to the font file currently in use.\"\"\"\n    self.fontname: str = None\n    \"\"\"Name of the font.\"\"\"\n    self.fontfamily: str = None\n    \"\"\"Font family.\"\"\"\n    self.figsize: tuple[float,float] = (4.8,4.8)\n    \"\"\"Figure size.\"\"\"\n\n    # Only bar format\n    self._spiral_defaults : dict = {\n        'bottom': 30,\n        'linewidth': 2,\n        'edgecolor': 'white',\n    }\n\n    mask_path = os.path.join(current_file_dir(), \"images\", \"mask.png\")\n    mask = mask_from_path(mask_path)\n    self._cloud_defaults = {\n        'background_color': None,\n        'mode': \"RGBA\",\n        'mask': mask,\n        'font_path': None,\n        'width': 1000,\n        'height': 1000,\n        'max_words': 200,\n        'prefer_horizontal': 0.75,\n        'repeat': True,\n        'max_font_size': 100,\n        'colormap': None\n    }\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings-attributes","title":"Attributes","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.fontpath","title":"<code>fontpath: str = None</code>  <code>instance-attribute</code>","text":"<p>Path to the font file currently in use.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.fontname","title":"<code>fontname: str = None</code>  <code>instance-attribute</code>","text":"<p>Name of the font.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.fontfamily","title":"<code>fontfamily: str = None</code>  <code>instance-attribute</code>","text":"<p>Font family.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.figsize","title":"<code>figsize: tuple[float, float] = (4.8, 4.8)</code>  <code>instance-attribute</code>","text":"<p>Figure size.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.spiral_defaults","title":"<code>spiral_defaults: dict</code>  <code>property</code> <code>writable</code>","text":"<p>Default parameters for bars in the spiral plot.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.cloud_defaults","title":"<code>cloud_defaults: dict</code>  <code>property</code> <code>writable</code>","text":"<p>Default arguments for WordCloud generation.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings-functions","title":"Functions","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.set_font","title":"<code>set_font(name)</code>","text":"<p>Set the font globally for plotting. This method updates the font settings for both WordCloud generation and Matplotlib plotting to use the specified font.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Matplotlib font name, such as <code>Arial</code>, <code>Verdana</code>, etc.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def set_font(self, name: str):\n    \"\"\"Set the font globally for plotting.\n    This method updates the font settings for both WordCloud generation\n    and Matplotlib plotting to use the specified font.\n\n    Args:\n        name (str): Matplotlib font name, such as `Arial`, `Verdana`, etc.\n    \"\"\"\n    font_path = matplotlib.font_manager.findfont(name)\n    prop = matplotlib.font_manager.FontProperties(fname=font_path)\n    self.fontpath = font_path\n    self.fontname = name\n    self.fontfamily = prop.get_family()\n    self.cloud_defaults = dict(font_path=font_path)\n\n    # Change matplotlib globally\n    matplotlib.rcParams[f'font.{self.fontfamily[0]}'] = self.fontname\n    matplotlib.rcParams['font.family'] = self.fontfamily[0]\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.PlotSettings.restore_font","title":"<code>restore_font()</code>","text":"<p>Restore default font from WordCloud and Matplotlib.</p> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def restore_font(self):\n    \"\"\"Restore default font from WordCloud and Matplotlib.\"\"\"\n    self.fontpath = None\n    self.fontname = None\n    self.fontfamily = None\n    self.cloud_defaults = dict(font_path=None)\n    matplotlib.rcdefaults()\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral","title":"<code>Spiral(settings=None)</code>","text":"<p>A class to generate spiral bar plots using given settings.</p> <p>Attributes:</p> <ul> <li> <code>settings</code>               (<code>PlotSettings</code>)           \u2013            <p>An instance of PlotSettings containing default plotting parameters.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>plot</code>             \u2013              <p>Generate a spiral bar plot.</p> </li> <li> <code>add_labels</code>             \u2013              <p>Helper function.</p> </li> <li> <code>get_ax</code>             \u2013              <p>Helper function.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>Optional[PlotSettings]</code>, default:                   <code>None</code> )           \u2013            <p>An instance of PlotSettings containing default plotting parameters.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def __init__(self, settings: Optional[PlotSettings] = None):\n    \"\"\"\n    Initialize a Spiral object.\n\n    Args:\n        settings: An instance of PlotSettings containing default plotting parameters.\n    \"\"\"\n    if settings:\n        self.settings = settings\n    else:\n        self.settings = PlotSettings()\n\n    self.settings : PlotSettings  \n    \"\"\"A [PlotSettings][ScanPyImports.plotter.PlotSettings] instance.\"\"\"\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral-attributes","title":"Attributes","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral.settings","title":"<code>settings: PlotSettings</code>  <code>instance-attribute</code>","text":"<p>A PlotSettings instance.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral-functions","title":"Functions","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral.plot","title":"<code>plot(labels=None, values=None, ax=None, zero_at='NE', label_padding=2, defaults=True, **kwargs)</code>","text":"<p>Generate a spiral bar plot.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Optional[List[str]]</code>, default:                   <code>None</code> )           \u2013            <p>List of labels for the bars.</p> </li> <li> <code>values</code>               (<code>Optional[List[Union[float, int]]]</code>, default:                   <code>None</code> )           \u2013            <p>List of values for the bars. Order values in ascending order for a spiral effect.</p> </li> <li> <code>ax</code>               (<code>Optional[PolarAxes]</code>, default:                   <code>None</code> )           \u2013            <p>The axes to plot on. If None, a new figure and axes are created.  The <code>ax</code> parameter must be an instance of PolarAxes.</p> </li> <li> <code>zero_at</code>               (<code>str</code>, default:                   <code>'NE'</code> )           \u2013            <p>Zero location for theta. Default is 'NE', which means that the largest value will point North-East (NE).  Other possible values: 'N', 'S', 'SE', 'NW', and 'SW'.</p> </li> <li> <code>label_padding</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Padding for the labels.</p> </li> <li> <code>defaults</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use default settings from the class.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the bar plot to be passed to Matplotlib (see: Axes.bar). If there is a collision, <code>kwargs</code> will overwrite default settings.</p> </li> </ul> Notes <p>The <code>ax</code> parameter, if passed, must be an instance of PolarAxes.</p> <p>When creating <code>ax</code>, you should pass <code>polar</code> as the projection argument. Here are two ways to achieve this:</p> <pre><code>from matplotlib import pyplot as plt\n\n# One way:\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\n\n# Another way:\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n</code></pre> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, PolarAxes, BarContainer, List[Text]]</code>           \u2013            <p>The figure, axes, bars, and texts of the plot.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>labels</code> and <code>values</code> are not provided or if their lengths do not match.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def plot(self, labels: Optional[List[str]] = None,\n         values: Optional[List[Union[float, int]]] = None,\n         ax: Optional[PolarAxes] = None,\n         zero_at: str = 'NE',\n         label_padding: int = 2,\n         defaults: bool = True,\n         **kwargs: Any) -&gt; Tuple[Figure, PolarAxes, BarContainer, List[Text]]:\n    \"\"\"\n    Generate a spiral bar plot.\n\n    Args:\n        labels: List of labels for the bars.\n        values: List of values for the bars. Order values in ascending order for a spiral effect.\n        ax: The axes to plot on. If None, a new figure and axes are created. \n            The `ax` parameter must be an instance of PolarAxes.\n        zero_at: Zero location for theta. Default is 'NE', which means that the largest value will point North-East (NE). \n            Other possible values: 'N', 'S', 'SE', 'NW', and 'SW'.\n        label_padding: Padding for the labels.\n        defaults: Whether to use default settings from the class.\n        **kwargs: Additional keyword arguments for the bar plot to be passed to Matplotlib (see: [Axes.bar][matplotlib.axes.Axes.bar]).\n            If there is a collision, `kwargs` will overwrite default settings.\n\n\n    Notes:\n        The `ax` parameter, if passed, must be an instance of [**PolarAxes**][matplotlib.projections.polar.PolarAxes].\n\n        When creating `ax`, you should pass `polar` as the projection argument. Here are two ways to achieve this:\n\n        ```python\n        from matplotlib import pyplot as plt\n\n        # One way:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection='polar')\n\n        # Another way:\n        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n        ```\n\n\n    Returns:\n        The figure, axes, bars, and texts of the plot.\n\n    Raises:\n        ValueError: If `labels` and `values` are not provided or if their lengths do not match.\n    \"\"\"\n    if labels is None or values is None:\n        raise ValueError(\"Both 'labels' and 'values' must be provided.\")\n    if len(labels) != len(values):\n        raise ValueError(\"Length of 'labels' and 'values' must be the same.\")\n\n    if defaults:\n        kwargs = {**self.settings.spiral_defaults, **kwargs}\n\n    val_max = max(values)\n    heights = [(val / val_max) * 120 + 5 for val in values]\n    n = len(labels)\n    width_bar = 2 * np.pi / n\n    thetas = [bar * width_bar for bar in range(1, n + 1)]\n\n    fig, ax = self.get_ax(ax)\n\n    ax.set_theta_zero_location(zero_at)\n    bars = ax.bar(x=thetas, height=heights, width=width_bar, **kwargs)\n\n    texts = self.add_labels(ax, bars, labels, thetas, heights, label_padding)\n\n    ax.set_axis_off()\n    return fig, ax, bars, texts\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral.add_labels","title":"<code>add_labels(ax, bars, labels, thetas, heights, label_padding)</code>","text":"<p>Helper function to add labels to the bars in the spiral plot.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Axes</code>)           \u2013            <p>The axes to add the labels to.</p> </li> <li> <code>bars</code>               (<code>BarContainer</code>)           \u2013            <p>The bars of the spiral plot.</p> </li> <li> <code>labels</code>               (<code>List[str]</code>)           \u2013            <p>List of labels for the bars.</p> </li> <li> <code>thetas</code>               (<code>List[float]</code>)           \u2013            <p>List of theta values for the bars.</p> </li> <li> <code>heights</code>               (<code>List[float]</code>)           \u2013            <p>List of heights for the bars.</p> </li> <li> <code>label_padding</code>               (<code>int</code>)           \u2013            <p>Padding for the labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Text]</code>           \u2013            <p>A list of Matplotlib text objects for the labels.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def add_labels(self, ax: Axes, bars: BarContainer, labels: List[str],\n                thetas: List[float], heights: List[float], label_padding: int) -&gt; List[Text]:\n    \"\"\"\n    Helper function to add labels to the bars in the spiral plot.\n\n    Args:\n        ax: The axes to add the labels to.\n        bars: The bars of the spiral plot.\n        labels: List of labels for the bars.\n        thetas: List of theta values for the bars.\n        heights: List of heights for the bars.\n        label_padding: Padding for the labels.\n\n    Returns:\n        A list of Matplotlib text objects for the labels.\n    \"\"\"\n    def theta_adj(theta):\n        return (theta + ax.get_theta_offset()) % (np.pi * 2)\n\n    def get_quadrant(theta):\n        return theta // (np.pi / 2)\n\n    def text_rot_theta(theta: float) -&gt; float:\n        quadrant = get_quadrant(theta_adj(theta))\n        rotation = theta_adj(theta)\n        if quadrant in [1, 2]:\n            rotation += np.pi\n        return rotation\n\n    def text_rot_degree(theta: float) -&gt; float:\n        return np.rad2deg(text_rot_theta(theta))\n\n    def text_ha(theta: float) -&gt; str:\n        return 'right' if get_quadrant(theta_adj(theta)) in [1, 2] else 'left'\n\n    bottom = bars[0].xy[1]\n    heights_pad = [y + label_padding + bottom for y in heights]\n\n    texts = []\n    for label, theta, y in zip(labels, thetas, heights_pad):\n        text = ax.text(\n            x=theta,\n            y=y,\n            s=label,\n            ha=text_ha(theta),\n            rotation=text_rot_degree(theta),\n            va='center',\n            rotation_mode=\"anchor\"\n        )\n        texts.append(text)\n    return texts\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Spiral.get_ax","title":"<code>get_ax(ax=None)</code>","text":"<p>Helper function to get or create a Matplotlib Figure and Axes.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Optional[PolarAxes]</code>, default:                   <code>None</code> )           \u2013            <p>An existing Matplotlib Axes object. </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, PolarAxes]</code>           \u2013            <p>A tuple containing the Figure and Axes of the plot. If an Axes object is passed, the Axes and its figure will be returned. Otherwise, a new figure and Axes will be created.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def get_ax(self, ax: Optional[PolarAxes] = None) -&gt; Tuple[Figure, PolarAxes]:\n    \"\"\"\n    Helper function to get or create a Matplotlib Figure and Axes.\n\n    Args:\n        ax: An existing Matplotlib Axes object. \n\n    Returns:\n        A tuple containing the Figure and Axes of the plot. If an Axes object is passed, the Axes and its figure will be returned. Otherwise, a new figure and Axes will be created.\n    \"\"\"\n    if ax is None:\n        fig = plt.figure(figsize=self.settings.figsize)\n        ax = fig.add_subplot(projection='polar')\n    else:\n        fig = ax.get_figure()\n    return fig, ax\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud","title":"<code>Cloud(settings=None)</code>","text":"<p>A class to generate word cloud plots using given settings.</p> <p>Attributes:</p> <ul> <li> <code>settings</code>               (<code>PlotSettings</code>)           \u2013            <p>An instance of PlotSettings containing default plotting parameters.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>plot</code>             \u2013              <p>Generate a word cloud.</p> </li> <li> <code>get_ax</code>             \u2013              <p>Helper function.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>settings</code>               (<code>Optional[PlotSettings]</code>, default:                   <code>None</code> )           \u2013            <p>An instance of PlotSettings containing default plotting parameters.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def __init__(self, settings: Optional[PlotSettings] = None) -&gt; None:\n    \"\"\"\n    Initialize a Cloud object.\n\n    Args:\n        settings: An instance of PlotSettings containing default plotting parameters. \n    \"\"\"\n    if settings:\n        self.settings = settings\n    else:\n        self.settings = PlotSettings()\n\n    self.settings: PlotSettings\n    \"\"\"An instance of PlotSettings for default plotting parameters.\"\"\"\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud-attributes","title":"Attributes","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud.settings","title":"<code>settings: PlotSettings</code>  <code>instance-attribute</code>","text":"<p>An instance of PlotSettings for default plotting parameters.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud-functions","title":"Functions","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud.plot","title":"<code>plot(data_dic, defaults=True, ax=None, imshow={}, **kwargs)</code>","text":"<p>Generate a word cloud.</p> <p>Parameters:</p> <ul> <li> <code>data_dic</code>               (<code>Dict[str, Union[int, float]]</code>)           \u2013            <p>Dictionary of word frequencies of label-value pairs.</p> </li> <li> <code>defaults</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use default settings of the Class.  </p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The axes to plot on. If None, a new figure and axes are created.</p> </li> <li> <code>imshow</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments to pass to the Matplotlib imshow method (see: Axes.imshow).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to the WordCloud object (see: wordcloud.WordCloud)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Axes, WordCloud, AxesImage]</code>           \u2013            <p>A tuple containing the figure, axes, WordCloud object, and AxesImage object of the plot.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def plot(self, data_dic: Dict[str, Union[int, float]], \n         defaults: bool = True, \n         ax: Optional[Axes] = None, \n         imshow: Optional[Dict[str, Any]] = {}, \n         **kwargs: Any ) -&gt; Tuple[Figure, Axes, WordCloud, AxesImage]:\n    \"\"\"\n    Generate a word cloud.\n\n    Args:\n        data_dic: Dictionary of word frequencies of label-value pairs.\n        defaults: Whether to use default settings of the Class.  \n        ax: The axes to plot on. If None, a new figure and axes are created.\n        imshow: Additional arguments to pass to the Matplotlib imshow method (see: [Axes.imshow][matplotlib.axes.Axes.imshow]).\n        **kwargs: Additional keyword arguments passed to the WordCloud object (see: [wordcloud.WordCloud](https://amueller.github.io/word_cloud/generated/wordcloud.WordCloud.html#wordcloud.WordCloud))\n\n    Returns:\n        A tuple containing the figure, axes, WordCloud object, and AxesImage object of the plot.\n    \"\"\"\n    if defaults:\n        kwargs = {**self.settings.cloud_defaults, **kwargs}\n\n    wc = WordCloud(**kwargs)\n    wc.generate_from_frequencies(data_dic)\n\n    fig, ax = self.get_ax(ax)\n    if imshow:\n        im = ax.imshow(wc, **imshow)\n    else:\n        im = ax.imshow(wc)    \n    ax.set_axis_off()\n\n    return fig, ax, wc, im\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.Cloud.get_ax","title":"<code>get_ax(ax=None)</code>","text":"<p>Helper function to get or create a Matplotlib Figure and Axes object.</p> <p>Parameters:</p> <ul> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>An existing Matplotlib Axes object. </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Axes]</code>           \u2013            <p>A tuple containing the figure and axes. If an Axes object is passed, the Axes and its figure will be returned. Otherwise, a new figure and Axes will be created.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def get_ax(self, ax: Optional[Axes] = None) -&gt; Tuple[Figure, Axes]:\n    \"\"\"\n    Helper function to get or create a Matplotlib Figure and Axes object.\n\n    Args:\n        ax: An existing Matplotlib Axes object. \n\n    Returns:\n        A tuple containing the figure and axes. If an Axes object is passed, the Axes and its figure will be returned. Otherwise, a new figure and Axes will be created.\n    \"\"\"\n    if ax is None:\n        fig = plt.figure(figsize=self.settings.figsize)\n        ax = fig.add_subplot()\n    else:\n        fig = ax.get_figure()\n    return fig, ax\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter","title":"<code>DataPlotter(path, to_exclude=None)</code>","text":"<p>               Bases: <code>DataAnalyzer</code></p> <p>DataPlotter extends DataAnalyzer to provide methods for visualizing data on imported modules.</p> <p>Methods:</p> <ul> <li> <code>get_frequencies</code>             \u2013              <p>Return frequency of imported modules.</p> </li> <li> <code>cloud_frequencies</code>             \u2013              <p>Generate a word cloud plot of data frequencies.</p> </li> <li> <code>spiral_frequencies</code>             \u2013              <p>Generate a spiral bar plot based on data frequencies.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the directory.</p> </li> <li> <code>to_exclude</code>               (<code>List[str]</code>, default:                   <code>None</code> )           \u2013            <p>List of packages' names to exclude from the analysis.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def __init__(self, path: str, to_exclude : List[str] = None):\n    \"\"\"Initiate DataPlotter.\n\n    Args:\n        path: Path to the directory.\n        to_exclude: List of packages' names to exclude from the analysis.\n    \"\"\"\n    super().__init__(path, to_exclude=to_exclude)\n    self.settings = PlotSettings() # setting shared by all plots\n    \"\"\"An instance of PlotSettings containing default plotting parameters.\"\"\"\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter-attributes","title":"Attributes","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>Path to the directory.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.directory","title":"<code>directory: Directory</code>  <code>instance-attribute</code>","text":"<p>An instance of Directory initiated with the given path.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.df","title":"<code>df: Optional[pd.DataFrame]</code>  <code>property</code>","text":"<p>DataFrame containing import data or None if the directory does not exist.</p> DataFrame content <p>The DataFrame contains the following columns: </p> <ul> <li><code>imported_0</code>, <code>imported_1</code>, ...     representing the imported  packages and modules.<ul> <li>where <code>imported_0</code> represents the top-level package or library being imported.</li> <li><code>imported_1</code> represents the module or submodule within the package being imported.</li> <li>and so on <code>imported_2</code> represent further nested modules, submodules if present in the import statement.</li> </ul> </li> <li><code>original</code>: The original line of text containing the import statement.</li> <li><code>alias</code>: Alias (if any) of the submodule.</li> <li><code>path</code>: Full path of the file containing the import.</li> <li><code>file</code>: File name.</li> <li><code>filename</code>: File name without extension.</li> <li><code>extension</code>: File extension.</li> <li><code>directory</code>: Directory path of the file.</li> </ul> <p>The data creation takes place in this private method. One could modify this code to retreive a dictionary or a JSON file instead of a DataFrame.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.to_exclude","title":"<code>to_exclude: List[str]</code>  <code>instance-attribute</code>","text":"<p>List of packages' names to exclude from the analysis.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.clean_df","title":"<code>clean_df: pd.DataFrame</code>  <code>property</code>","text":"<p>A cleaned copy of df after conducting some minor changes.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.own_processed_df","title":"<code>own_processed_df: pd.DataFrame</code>  <code>property</code>","text":"<p>A copy of the DataFrame (df) after processing own-created modules.</p> Own-created modules <p>Own-created modules are defined as Python scripts that are imported as modules and reside in the same folder as the script containing the import statement.</p> <p>A natural extension would be to also include own-created packages residing in the same folder as the .py or .ipynb file where the import statment resides.</p> <p>In the returned DataFrame, own-created modules are dropped and replaced by the import statements residing inside the own-created module script, provided they relate to external libraries.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.settings","title":"<code>settings = PlotSettings()</code>  <code>instance-attribute</code>","text":"<p>An instance of PlotSettings containing default plotting parameters.</p>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter-functions","title":"Functions","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.get_frequencies","title":"<code>get_frequencies(exclude=True, process_own_modules=True)</code>","text":"<p>Get the frequency of imported modules.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to exclude the packages listed in to_exclude.</p> </li> <li> <code>process_own_modules</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to process own-created modules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>pd.Series: Series of import frequencies sorted in descending order.</p> </li> </ul> Source code in <code>ScanPyImports/analyzer.py</code> <pre><code>def get_frequencies(self, exclude: bool = True, process_own_modules: bool = True) -&gt; pd.Series:\n    \"\"\"\n    Get the frequency of imported modules.\n\n    Args:\n        exclude: Whether to exclude the packages listed in [to_exclude][ScanPyImports.analyzer.DataAnalyzer.to_exclude].\n        process_own_modules: Whether to process own-created modules.\n\n    Returns:\n        pd.Series: Series of import frequencies sorted in descending order.\n    \"\"\"\n    df = self.own_processed_df if process_own_modules else self.clean_df\n    count_series = (df.groupby('imported_0')\n                    .size()\n                    .sort_values(ascending=False))\n\n    count_series.index.name = 'Imports'\n\n    if exclude:\n        count_series = count_series[~count_series.index.isin(self.to_exclude)]\n\n    return count_series\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.cloud_frequencies","title":"<code>cloud_frequencies(exclude=True, process_own_modules=True, defaults=True, ax=None, imshow=None, **kwargs)</code>","text":"<p>Generate a word cloud plot of data frequencies.</p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to exclude the packages listed in to_exclude.</p> </li> <li> <code>process_own_modules</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to process own-created modules.</p> </li> <li> <code>defaults</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use default settings defined in settings.</p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The axes to plot on. If None, a new figure and axes are created.</p> </li> <li> <code>imshow</code>               (<code>Optional[Dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional arguments to pass to the Matplotlib imshow method (see: Axes.imshow).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to the WordCloud object (see: wordcloud.WordCloud)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Axes, WordCloud, AxesImage]</code>           \u2013            <p>The figure, axe , WordCloud object, and image axe.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def cloud_frequencies(self\n                      , exclude: bool = True\n                      , process_own_modules: bool = True\n                      , defaults: bool = True\n                      , ax: Optional[Axes] = None\n                      , imshow: Optional[Dict[str, Any]] = None\n                      , **kwargs: Any) -&gt; Tuple[Figure, Axes, WordCloud, AxesImage]: \n    \"\"\"Generate a word cloud plot of data frequencies.\n\n    Args:\n        exclude: Whether to exclude the packages listed in [to_exclude][ScanPyImports.plotter.DataPlotter.to_exclude].\n        process_own_modules: Whether to process own-created modules.\n        defaults: Whether to use default settings defined in [settings][ScanPyImports.plotter.DataPlotter.settings].\n        ax: The axes to plot on. If None, a new figure and axes are created.\n        imshow: Additional arguments to pass to the Matplotlib imshow method (see: [Axes.imshow][matplotlib.axes.Axes.imshow]).\n        **kwargs: Additional keyword arguments passed to the WordCloud object (see: [wordcloud.WordCloud](https://amueller.github.io/word_cloud/generated/wordcloud.WordCloud.html#wordcloud.WordCloud))\n\n    Returns:\n        The figure, axe , WordCloud object, and image axe.\n    \"\"\"\n    s = self.get_frequencies(exclude=exclude,\n                             process_own_modules=process_own_modules)\n\n    cloud_plot = Cloud(self.settings)\n    fig, ax, wc, im = cloud_plot.plot(data_dic=dict(s), defaults=defaults,\n                           ax=ax, imshow=imshow, **kwargs)\n    return fig, ax, wc, im \n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.DataPlotter.spiral_frequencies","title":"<code>spiral_frequencies(exclude=True, process_own_modules=True, top=25, ax=None, zero_at='NE', defaults=True, label_padding=2, **kwargs)</code>","text":"<p>Generate a spiral bar plot based on data frequencies. </p> <p>Parameters:</p> <ul> <li> <code>exclude</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to exclude the packages listed in to_exclude.</p> </li> <li> <code>process_own_modules</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to process own-created modules.</p> </li> <li> <code>defaults</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use default settings defined in settings.</p> </li> <li> <code>ax</code>               (<code>Optional[Axes]</code>, default:                   <code>None</code> )           \u2013            <p>The axes to plot on. If None, a new figure and axes are created.</p> </li> <li> <code>top</code>               (<code>Optional[int]</code>, default:                   <code>25</code> )           \u2013            <p>Number of top most frequent modules to include. If None, all modules are included.</p> </li> <li> <code>zero_at</code>               (<code>str</code>, default:                   <code>'NE'</code> )           \u2013            <p>Zero location for theta. Default is 'NE', which means that the largest value will point North-East (NE).  Other possible values: 'N', 'S', 'SE', 'NW', and 'SW'.</p> </li> <li> <code>label_padding</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>Padding for the labels.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments for the bar plot (see: Axes.bar)</p> </li> </ul> Notes <p>The <code>ax</code> parameter, if passed, must be an instance of PolarAxes.</p> <p>When creating <code>ax</code>, you should pass <code>polar</code> as the projection argument. Here are two ways to achieve this:</p> <pre><code>from matplotlib import pyplot as plt\n\n# One way:\nfig = plt.figure()\nax = fig.add_subplot(projection='polar')\n\n# Another way:\nfig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n</code></pre> <p>Returns:</p> <ul> <li> <code>Tuple[Figure, Axes, BarContainer, List[Text]]</code>           \u2013            <p>The figure, axes, bars, and texts of the plot.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def spiral_frequencies(self, exclude: bool = True\n                       , process_own_modules: bool = True\n                       , top: Optional[int] = 25\n                       , ax: Optional[Axes] = None\n                       , zero_at: str = 'NE'\n                       , defaults: bool = True\n                       , label_padding: int = 2\n                       , **kwargs: Any) -&gt; Tuple[Figure, Axes, BarContainer, List[Text]]:\n    \"\"\" \n    Generate a spiral bar plot based on data frequencies. \n\n    Args:\n        exclude: Whether to exclude the packages listed in [to_exclude][ScanPyImports.plotter.DataPlotter.to_exclude].\n        process_own_modules: Whether to process own-created modules.\n        defaults: Whether to use default settings defined in [settings][ScanPyImports.plotter.DataPlotter.settings].\n        ax: The axes to plot on. If None, a new figure and axes are created.\n        top: Number of top most frequent modules to include. If None, all modules are included.\n        zero_at: Zero location for theta. Default is 'NE', which means that the largest value will point North-East (NE). \n            Other possible values: 'N', 'S', 'SE', 'NW', and 'SW'.\n        label_padding: Padding for the labels.\n        **kwargs: Additional keyword arguments for the bar plot (see: [Axes.bar][matplotlib.axes.Axes.bar])\n\n    Notes:\n        The `ax` parameter, if passed, must be an instance of [**PolarAxes**][matplotlib.projections.polar.PolarAxes].\n\n        When creating `ax`, you should pass `polar` as the projection argument. Here are two ways to achieve this:\n\n        ```python\n        from matplotlib import pyplot as plt\n\n        # One way:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection='polar')\n\n        # Another way:\n        fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})\n        ```\n\n\n    Returns:\n        The figure, axes, bars, and texts of the plot.\n    \"\"\"\n    s = self.get_frequencies(exclude=exclude,\n                            process_own_modules=process_own_modules)\n\n    if top is not None:\n        s = s[:top]\n\n    s = s.sort_values()\n    values = list(s.values)\n    labels = list(s.index)\n\n    spiral = Spiral(self.settings)\n    fig, ax, bars, texts = spiral.plot(labels=labels, values=values,\n                                        ax=ax, zero_at=zero_at, defaults=defaults,label_padding=label_padding, **kwargs)\n\n    return fig, ax, bars, texts \n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter-functions","title":"Functions","text":""},{"location":"Api/plotter/#ScanPyImports.plotter.current_file_dir","title":"<code>current_file_dir()</code>","text":"<p>Get the directory containing the current file.</p> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def current_file_dir() -&gt; str:\n    \"\"\"Get the directory containing the current file.\"\"\"\n    try:\n        return os.path.dirname(os.path.abspath(__file__))\n    except:\n        return os.path.dirname(os.path.abspath('__file__'))\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.mask_from_path","title":"<code>mask_from_path(path)</code>","text":"<p>Loads an image from the given path and returns it as a NumPy array.</p> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def mask_from_path(path: str) -&gt; np.ndarray:\n    \"\"\"Loads an image from the given path and returns it as a NumPy array.\"\"\"\n    mask = np.array(Image.open(path))\n    return mask\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.get_fontname_list","title":"<code>get_fontname_list()</code>","text":"<p>Get a list of available font names.</p> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def get_fontname_list():\n    \"\"\"Get a list of available font names.\"\"\"\n    return sorted(matplotlib.font_manager.get_font_names())\n</code></pre>"},{"location":"Api/plotter/#ScanPyImports.plotter.color_list","title":"<code>color_list(n=3, colormap='Blues', lower=0.3, upper=1.0, hex_colors=True, reversed_cmap=False)</code>","text":"<p>List of color codes based on the specified Matplotlib colormap. </p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The number of color codes to be generated. </p> </li> <li> <code>colormap</code>               (<code>str</code>, default:                   <code>'Blues'</code> )           \u2013            <p>The name of the colormap to be used.</p> </li> <li> <code>lower</code>               (<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The lower bound of the color range to be selected from the colormap.</p> </li> <li> <code>upper</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The upper bound of the color range to be selected from the colormap.</p> </li> <li> <code>hex_colors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the color codes will be returned in hexadecimal format otherwise colors are in RGBA format.</p> </li> <li> <code>reversed_cmap</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>List colors in reverse order.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of <code>n</code> color codes in either hexadecimal or RGBA format.</p> </li> </ul> Source code in <code>ScanPyImports/plotter.py</code> <pre><code>def color_list(n : int = 3, colormap : str = 'Blues' , lower : float = 0.3,  upper : float = 1.0 , hex_colors : bool = True , reversed_cmap : bool = False) -&gt; list :  \n    \"\"\"List of color codes based on the specified Matplotlib colormap. \n\n    Args:\n        n: The number of color codes to be generated. \n        colormap: The name of the colormap to be used.\n        lower: The lower bound of the color range to be selected from the colormap.\n        upper: The upper bound of the color range to be selected from the colormap.\n        hex_colors: If True, the color codes will be returned in hexadecimal format otherwise colors are in RGBA format.\n        reversed_cmap: List colors in reverse order.\n\n    Returns:\n        A list of `n` color codes in either hexadecimal or RGBA format.\n    \"\"\"\n    if colormap:\n        # Get matplotlib colormap \n        colormap = matplotlib.colormaps[colormap]\n\n        # Select colors list\n        colors =  colormap(np.linspace(lower, upper, n ))\n\n        # If reversed colors \n        if reversed_cmap :\n            colors = colors[::-1]\n\n        if hex_colors :\n            # Convert color codes to hexadecimal format\n            colors = [matplotlib.colors.to_hex(c) for c in colors]\n\n        return colors\n</code></pre>"},{"location":"Api/scan/","title":"Scan","text":""},{"location":"Api/scan/#ScanPyImports.scan","title":"<code>ScanPyImports.scan</code>","text":"<p>This module provides a set of classes and functions to extract import statements from Python files (<code>.py</code>) and Jupyter notebooks (<code>.ipynb</code>) of a given directory.</p> <p>Classes:</p> <ul> <li> <code>Line</code>           \u2013            <p>Parses a single import statement.</p> </li> <li> <code>File</code>           \u2013            <p>Manages the parsing of Python files and Jupyter notebooks.</p> </li> <li> <code>Directory</code>           \u2013            <p>Manages a collection of files in a directory, extracting import statements from all Python and notebook files found.</p> </li> </ul>"},{"location":"Api/scan/#ScanPyImports.scan-classes","title":"Classes","text":""},{"location":"Api/scan/#ScanPyImports.scan.Line","title":"<code>Line(text)</code>","text":"<p>A single import statement.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>A string with an import statement.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def __init__(self, text: str) -&gt; None:\n    \"\"\"\n    Initialize a Line object.\n\n    Args:\n        text: A string with an import statement.\n    \"\"\"\n    self.original = text\n    self.lfrom,self.limports = self.get_from_import(self.original)\n    self.imports = self.get_imports(self.lfrom,self.limports )\n    self.imports, self.alias = self.get_alias_list(self.imports)\n    # self.alias, self.statement = self.get_alias(text) \n\n    # Documentation\n    self.original: str \n    \"\"\"The original line of code with the import statement.\"\"\"\n    self.lfrom: str  \n    \"\"\"The `from` part of the import statement, if any.\"\"\"\n    self.limports: str  \n    \"\"\"The `import` part of the import statement.\"\"\"\n    self.imports: List[List[str]] \n    \"\"\"A list of lists, where each inner list represents an imported submodule, containing the package name, modules, and the submodule itself.\"\"\"\n    self.alias: List[str] \n    \"\"\"The aliases used in the import statement, if any.\"\"\"\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line-attributes","title":"Attributes","text":""},{"location":"Api/scan/#ScanPyImports.scan.Line.original","title":"<code>original: str</code>  <code>instance-attribute</code>","text":"<p>The original line of code with the import statement.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Line.lfrom","title":"<code>lfrom: str</code>  <code>instance-attribute</code>","text":"<p>The <code>from</code> part of the import statement, if any.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Line.limports","title":"<code>limports: str</code>  <code>instance-attribute</code>","text":"<p>The <code>import</code> part of the import statement.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Line.imports","title":"<code>imports: List[List[str]]</code>  <code>instance-attribute</code>","text":"<p>A list of lists, where each inner list represents an imported submodule, containing the package name, modules, and the submodule itself.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Line.alias","title":"<code>alias: List[str]</code>  <code>instance-attribute</code>","text":"<p>The aliases used in the import statement, if any.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Line-functions","title":"Functions","text":""},{"location":"Api/scan/#ScanPyImports.scan.Line.compile_alias","title":"<code>compile_alias()</code>","text":"<p>Match alias in import statements.</p> <p>Returns:</p> <ul> <li> <code>Pattern</code>           \u2013            <p>A compiled regular expression pattern.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def compile_alias(self) -&gt; re.Pattern:\n    \"\"\"Match alias in import statements.\n\n    Returns:\n        A compiled regular expression pattern.\n    \"\"\"\n    pattern = r'(.*?)(\\bas\\b)( .*)'\n    return re.compile(pattern)\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line.compile_from_import","title":"<code>compile_from_import()</code>","text":"<p>Match and group <code>from</code> package and <code>import</code> modules  from statements.</p> <p>Returns:</p> <ul> <li> <code>Pattern</code>           \u2013            <p>A compiled regular expression pattern.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def compile_from_import(self) -&gt; re.Pattern:\n    \"\"\"\n    Match and group `from` package and `import` modules \n    from statements.\n\n    Returns:\n        A compiled regular expression pattern.\n    \"\"\"\n    pattern = r'(?:from(.*?))*(?:import)(.*)'\n    return re.compile(pattern)\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line.get_from_import","title":"<code>get_from_import(statement)</code>","text":"<p>Extract from-import components from the line of code.</p> <p>Parameters:</p> <ul> <li> <code>statement</code>               (<code>str</code>)           \u2013            <p>Line of code. </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, str]</code>           \u2013            <p>A tuple containing the 'from' part and the 'import' part.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_from_import(self, statement:str) -&gt; Tuple[str, str]:\n    \"\"\"\n    Extract from-import components from the line of code.\n\n    Args:\n        statement: Line of code. \n\n    Returns:\n        A tuple containing the 'from' part and the 'import' part.\n    \"\"\"\n    compiled = self.compile_from_import()\n    c = compiled.search(statement)\n    if c is None:\n        lfrom, limport  =  \"\", \"\" # False, False\n    else:\n        from_import = c.groups()\n        from_import = [i.replace('(','').strip() if i is not None else '' for i in from_import]\n        lfrom, limport = from_import\n    return lfrom, limport\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line.get_imports","title":"<code>get_imports(lfrom, limports)</code>","text":"<p>Extract the imported submodules from the import statement.</p> <p>Each imported submodule is represented as an ordered list containing:</p> <ul> <li>The package of the submodule</li> <li>The module</li> <li>The submodule</li> <li>...</li> <li>The submodule itself with alias, if any.</li> </ul> <p>Returns:</p> <ul> <li> <code>List[List[str]]</code>           \u2013            <p>A list of lists, where each inner list represents an imported submodule.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_imports(self, lfrom: str, limports:str) -&gt; List[List[str]]:\n    \"\"\"\n    Extract the imported submodules from the import statement.\n\n    Each imported submodule is represented as an ordered list containing:\\n\n    - The package of the submodule\n    - The module\n    - The submodule\n    - ...\n    - The submodule itself with alias, if any.\n\n    Returns:\n            A list of lists, where each inner list represents an imported submodule.\n    \"\"\"\n    from_items = lfrom.split(\".\") if lfrom else []\n    import_items = [i.strip() for i in limports.split(',')]\n\n    imported_list = []\n    for i in import_items:\n        i_list = from_items + i.split('.')\n        imported_list.append(i_list)\n\n    return imported_list\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line.get_alias_list","title":"<code>get_alias_list(imports)</code>","text":"<p>Get the alias list and subtract aliases from the import list.</p> <p>Parameters:</p> <ul> <li> <code>imports</code>               (<code>List[List[str]]</code>)           \u2013            <p>List of imported submodules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[List[List[str]], List[str]]</code>           \u2013            <p>List of imports without aliases, and list of aliases. Both lists have the same length. Empty strings indicate that the submodule does not have an alias.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_alias_list(self, imports: List[List[str]])-&gt; Tuple[List[List[str]], List[str]]:\n    \"\"\"Get the alias list and subtract aliases from the import list.\n\n    Args:\n        imports: List of imported submodules.\n\n    Returns:\n        List of imports without aliases, and list of aliases. Both lists have the same length. Empty strings indicate that the submodule does not have an alias. \n    \"\"\"\n    alias_list = []\n    for item in imports:\n        alias, submodule = self.get_alias(item[-1])\n        item[-1] = submodule\n        alias_list.append(alias)\n\n    return imports, alias_list \n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Line.get_alias","title":"<code>get_alias(statement)</code>","text":"<p>Extract alias from the line of code.</p> <p>Parameters:</p> <ul> <li> <code>statement</code>               (<code>str</code>)           \u2013            <p>Line of code. </p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, str]</code>           \u2013            <p>A tuple containing the alias and the statement without the alias.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_alias(self, statement:str) -&gt; Tuple[str, str]:\n    \"\"\"Extract alias from the line of code.\n\n    Args:\n        statement: Line of code. \n\n    Returns:\n        A tuple containing the alias and the statement without the alias.\n    \"\"\"        \n    compiled = self.compile_alias()\n    c = compiled.search(statement)\n    if c is None:\n        alias = \"\"\n        line = statement\n    else:\n        line = c.group(1).strip()\n        alias = c.group(3).strip()\n    return alias, line\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File","title":"<code>File(filepath)</code>","text":"<p>A Python file or a Jypiter notebook.</p> <p>A File class bundles a set of Line objects.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>Path to the Python file or notebook file.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def __init__(self, filepath: str) -&gt; None:\n    \"\"\"\n    Initialize a File object.\n\n    Args:\n        filepath: Path to the Python file or notebook file.\n    \"\"\"\n    self.file = filepath\n    self.extension = filepath.split('.')[-1]\n    self.code = self.get_code()\n    self.code_lines = self.get_code_lines()\n    self.statements = self.get_import_lines(self.code_lines)\n    self.has_imports = len(self.statements) &gt; 0\n    self.lines = self.get_lines_obj()\n\n    # Documentation \n    self.file: str  \n    \"\"\"Path to the Python or notebook file.\"\"\"\n    self.extension: str  \n    \"\"\"The file extension (i.e. py or ipynb)\"\"\"\n    self.code: str  \n    \"\"\"Text from py file or notebook.\"\"\"\n    self.code_lines: List[str]  \n    \"\"\"All lines of code in the file.\"\"\"\n    self.statements: List[str] \n    \"\"\"List of import statements in the file.\"\"\"\n    self.has_imports : bool \n    \"\"\"Indicates if the file has any import statements.\"\"\"\n    self.lines: List[Line]  \n    \"\"\"[Line][ScanPyImports.scan.Line] objects for each import statement.\"\"\"\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File-attributes","title":"Attributes","text":""},{"location":"Api/scan/#ScanPyImports.scan.File.file","title":"<code>file: str</code>  <code>instance-attribute</code>","text":"<p>Path to the Python or notebook file.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.extension","title":"<code>extension: str</code>  <code>instance-attribute</code>","text":"<p>The file extension (i.e. py or ipynb)</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.code","title":"<code>code: str</code>  <code>instance-attribute</code>","text":"<p>Text from py file or notebook.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.code_lines","title":"<code>code_lines: List[str]</code>  <code>instance-attribute</code>","text":"<p>All lines of code in the file.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.statements","title":"<code>statements: List[str]</code>  <code>instance-attribute</code>","text":"<p>List of import statements in the file.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.has_imports","title":"<code>has_imports: bool</code>  <code>instance-attribute</code>","text":"<p>Indicates if the file has any import statements.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File.lines","title":"<code>lines: List[Line]</code>  <code>instance-attribute</code>","text":"<p>Line objects for each import statement.</p>"},{"location":"Api/scan/#ScanPyImports.scan.File-functions","title":"Functions","text":""},{"location":"Api/scan/#ScanPyImports.scan.File.remove_all_comments","title":"<code>remove_all_comments(code)</code>","text":"<p>Remove comments from code. </p> <p>Parameters:</p> <ul> <li> <code>code</code>               (<code>str</code>)           \u2013            <p>Line of code</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Line of code with  comments removed.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def remove_all_comments(self, code:str) -&gt; str:\n    \"\"\"Remove comments from code. \n\n    Args:\n        code: Line of code\n\n    Returns:\n        Line of code with  comments removed.\n    \"\"\"        \n    pattern = r'\\\"\\\"\\\"(.|\\n)*?\\\"\\\"\\\"|\\'\\'\\'(.|\\n)*?\\'\\'\\'|(#.*)'\n    # Explanation of the pattern:\n    # r'\\\"\\\"\\\"(.|\\n)*?\\\"\\\"\\\"' matches triple double quoted strings,\n    # r'\\'\\'\\'(.|\\n)*?\\'\\'\\'' matches triple single quoted strings,\n    # r'(#.*)' matches single-line comments\n    return re.sub(pattern, '', code)\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File.get_code","title":"<code>get_code()</code>","text":"<p>Get code text from py file or notebook.</p> <p>For Jupyter notebooks, only the content of the code cells is extracted and returned as a single string.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The content of the Python file or the concatenated code cells from the Jupyter notebook.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_code(self) -&gt; str:\n    \"\"\"\n    Get code text from py file or notebook.\n\n    For Jupyter notebooks, only the content of the code cells is extracted and returned as a single string.\n\n    Returns: \n        The content of the Python file or the concatenated code cells from the Jupyter notebook.\n\n    \"\"\"\n    if self.extension == 'py':\n        try:\n            with open(self.file, encoding='utf-8') as py:\n                file = py.read()\n            return file \n        except Exception as e:\n            if '__MACOSX' not in self.file:\n                print(f'ERROR: Cannot read {self.file}')\n                print(e)  \n    else: # ipynb\n        try:\n            with open(self.file, encoding='utf-8') as nb:\n                notebook = nbformat.read(nb, nbformat.NO_CONVERT)\n        except Exception as e:\n            print(f'ERROR: Cannot read {self.file}')   \n            print(e)\n        else: \n            code_cells = [c.source for c in notebook.cells \n                          if c.cell_type == 'code']\n            file = \"\\n\".join(code_cells)\n            return file   \n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File.get_code_lines","title":"<code>get_code_lines()</code>","text":"<p>Extracts all lines of code from the file.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of strings, each representing a line of code without comments.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_code_lines(self) -&gt; List[str]:\n    \"\"\"\n    Extracts all lines of code from the file.\n\n    Returns:\n        A list of strings, each representing a line of code without comments.\n    \"\"\"\n    if not self.code:\n        lines = []\n    else:\n        # exclude comments \n        code = self.remove_all_comments(self.code)\n        # code to lines \n        lines: List[str] = code.split('\\n')\n\n    return lines \n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File.compile_import","title":"<code>compile_import()</code>","text":"<p>Match text starting with either <code>import</code> or <code>from</code>.</p> <p>Text can be precedeed by blanks.</p> <p>Returns:</p> <ul> <li> <code>Pattern</code>           \u2013            <p>Compiled pattern</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def compile_import(self) -&gt; re.Pattern:\n    \"\"\"\n    Match text starting with either `import` or `from`.\n\n    Text can be precedeed by blanks.\n\n    Returns:\n        Compiled pattern\n    \"\"\"\n    pattern = r'^\\s*(import|from) '\n    return re.compile(pattern, flags=re.MULTILINE)\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File.get_import_lines","title":"<code>get_import_lines(lines)</code>","text":"<p>Extract import statements of the file.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>List[str]</code>)           \u2013            <p>A list of strings, each representing a line of code.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of strings with the import statement.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_import_lines(self, lines:List[str]) -&gt; List[str]:\n    \"\"\"Extract import statements of the file.\n\n    Args: \n        lines: A list of strings, each representing a line of code.\n\n    Returns:\n        A list of strings with the import statement.\n    \"\"\"\n    c = self.compile_import()\n    import_lines = []\n    for l in lines:\n        if c.search(l):\n            import_lines.append(l.strip())\n    return import_lines\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.File.get_lines_obj","title":"<code>get_lines_obj()</code>","text":"<p>Line objects of the file.</p> <p>Returns:</p> <ul> <li> <code>List[Line]</code>           \u2013            <p>A list of Line objects if the file has import statements,    otherwise an empty list.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_lines_obj(self) -&gt; List[Line]:\n    \"\"\"\n    Line objects of the file.\n\n    Returns:\n        A list of Line objects if the file has import statements,    otherwise an empty list. \n    \"\"\"\n    if self.has_imports:\n        lines = [Line(l) for l in self.statements]\n    else:\n        lines = []\n    return lines\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Directory","title":"<code>Directory(path)</code>","text":"<p>The root directory that bundles a set of File objects. </p> <p>Files in the root directory are scanned in search for import statements.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the directory. Path to python or notebook files are also accepted.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def __init__(self, path: str) -&gt; None:\n    \"\"\"\n    Initialize a Directory object.\n\n    Args:\n        path: Path to the directory. Path to python or notebook files are also accepted.\n    \"\"\"\n    self.path = path\n    try:\n        if os.path.exists(path) is False:\n            self.exists = False\n            raise Exception(f'ERROR: Path \"{path}\" does not exist.')\n    except Exception as e:\n        print(e)\n    else:\n        self.exists= True\n        self.isfile = os.path.isfile(path)\n        self.isdir = not self.isfile\n        self.filepaths = self.get_filepaths()\n        self.files = self.get_files_obj()\n\n    # Documentation \n    self.path: str \n    \"\"\"Path to the directory.\"\"\"\n    self.exists: bool  \n    \"\"\"Indicates if the directory exists.\"\"\"\n    self.isfile: bool  \n    \"\"\"Indicates if the path is a file.\"\"\"\n    self.isdir: bool  \n    \"\"\"Indicates if the path is a directory.\"\"\"\n    self.filepaths: List[str]  \n    \"\"\"Paths to .py or .ipynb files in the directory.\"\"\"\n    self.files: Optional[List[File]] \n    \"\"\"[File][ScanPyImports.scan.File] objects for each file path.\"\"\"\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Directory-attributes","title":"Attributes","text":""},{"location":"Api/scan/#ScanPyImports.scan.Directory.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>Path to the directory.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.exists","title":"<code>exists: bool</code>  <code>instance-attribute</code>","text":"<p>Indicates if the directory exists.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.isfile","title":"<code>isfile: bool</code>  <code>instance-attribute</code>","text":"<p>Indicates if the path is a file.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.isdir","title":"<code>isdir: bool</code>  <code>instance-attribute</code>","text":"<p>Indicates if the path is a directory.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.filepaths","title":"<code>filepaths: List[str]</code>  <code>instance-attribute</code>","text":"<p>Paths to .py or .ipynb files in the directory.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.files","title":"<code>files: Optional[List[File]]</code>  <code>instance-attribute</code>","text":"<p>File objects for each file path.</p>"},{"location":"Api/scan/#ScanPyImports.scan.Directory-functions","title":"Functions","text":""},{"location":"Api/scan/#ScanPyImports.scan.Directory.get_filepaths","title":"<code>get_filepaths()</code>","text":"<p>Get paths to .py and .ipynb files within a directory and its subdirectories.</p> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of file paths.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_filepaths(self) -&gt; List[str]:\n    \"\"\"\n    Get paths to .py and .ipynb files within a directory and its subdirectories.\n\n    Returns:\n        A list of file paths.\n    \"\"\"\n    if not self.exists:\n        return []\n\n    if self.isdir:\n        filepaths = []\n        for dirpath, dirnames, filenames in os.walk(self.path):\n            for filename in filenames:\n                if filename.endswith(\".py\") or filename.endswith(\".ipynb\") :\n                    filepath = os.path.join(dirpath, filename)\n                    filepaths.append(filepath)\n    else:\n        filepaths = [self.path]\n\n    return filepaths\n</code></pre>"},{"location":"Api/scan/#ScanPyImports.scan.Directory.get_files_obj","title":"<code>get_files_obj()</code>","text":"<p>Get File objects for each file path.</p> <p>Returns:</p> <ul> <li> <code>Optional[List[File]]</code>           \u2013            <p>A list of File objects or None if the directory does not exist.</p> </li> </ul> Source code in <code>ScanPyImports/scan.py</code> <pre><code>def get_files_obj(self) -&gt; Optional[List[File]]:\n    \"\"\"\n    Get File objects for each file path.\n\n    Returns:\n        A list of File objects or None if the directory does not exist.\n    \"\"\"\n    if not self.exists:\n        return None\n    files = [File(path) for path in self.filepaths]\n    return files\n</code></pre>"},{"location":"Examples/CustomBasic/","title":"Basics","text":"<p>There are several ways to customize your visualizations:</p> <p>Besides modifying the parameters as shown here, you can:</p> <ol> <li>Work with Returned Values after creating your visualizations.</li> <li>Pass Keyword Arguments (<code>kwargs</code>) when calling methods such as spiral_frequencies, cloud_frequencies, and plot.</li> <li>Adjust Settings.</li> </ol> In\u00a0[1]: Copied! <pre>from ScanPyImports.plotter import DataPlotter\nimport matplotlib.pyplot as plt\n</pre> from ScanPyImports.plotter import DataPlotter import matplotlib.pyplot as plt <p>Generate the spiral plot.</p> In\u00a0[2]: Copied! <pre>plotter = DataPlotter('../../ScanPyImports')\n\n# Get the figure, axes, bars, and texts from the spiral frequencies plot\nfig, ax, bars, texts = plotter.spiral_frequencies()\n\n# If you prefer, you can use the Spiral class instead \n# fig, ax, bars, texts = spiral.plot(labels, values)\n</pre> plotter = DataPlotter('../../ScanPyImports')  # Get the figure, axes, bars, and texts from the spiral frequencies plot fig, ax, bars, texts = plotter.spiral_frequencies()  # If you prefer, you can use the Spiral class instead  # fig, ax, bars, texts = spiral.plot(labels, values) <p>Work with the returned <code>ax</code>, <code>bars</code> and <code>texts</code>.</p> In\u00a0[3]: Copied! <pre># Get the color of the bars\ncolor = bars[0].get_facecolor()\n\n# Add a title to the plot\ntitle = ax.set_title('ScanPyImports',\n                     color='white',\n                     weight='bold',\n                     loc='left',\n                     y=0.9, x=0.1,\n                     bbox=dict(boxstyle='round',\n                               edgecolor=color,\n                               facecolor=color),\n                     fontsize='xx-large'\n                     )\n\n# Change the color of the bar labels\nfor text in texts:\n    text.set_color(color)\n\n# Return the figure\nfig\n</pre> # Get the color of the bars color = bars[0].get_facecolor()  # Add a title to the plot title = ax.set_title('ScanPyImports',                      color='white',                      weight='bold',                      loc='left',                      y=0.9, x=0.1,                      bbox=dict(boxstyle='round',                                edgecolor=color,                                facecolor=color),                      fontsize='xx-large'                      )  # Change the color of the bar labels for text in texts:     text.set_color(color)  # Return the figure fig Out[3]: In\u00a0[4]: Copied! <pre>_ = plotter.spiral_frequencies(facecolor = 'red')\n</pre> _ = plotter.spiral_frequencies(facecolor = 'red') In\u00a0[5]: Copied! <pre>_ = plotter.cloud_frequencies(colormap = 'Dark2')\n</pre> _ = plotter.cloud_frequencies(colormap = 'Dark2') In\u00a0[6]: Copied! <pre>plotter.settings.set_font('impact')\n_ = plotter.cloud_frequencies()\n</pre> plotter.settings.set_font('impact') _ = plotter.cloud_frequencies() <p>Otherwise, you can check which fonts are available on your computer.</p> In\u00a0[7]: Copied! <pre>from ScanPyImports.plotter import get_fontname_list\nget_fontname_list()[:5]\n</pre> from ScanPyImports.plotter import get_fontname_list get_fontname_list()[:5] Out[7]: <pre>['Agency FB', 'Algerian', 'Arial', 'Arial Rounded MT Bold', 'Bahnschrift']</pre> <p>Finally, you can always restore the original font using <code>restore_font()</code>.</p> In\u00a0[8]: Copied! <pre>plotter.settings.restore_font()\n</pre> plotter.settings.restore_font() In\u00a0[9]: Copied! <pre># Get the default settings for the spiral plot\ndefaults = plotter.settings.spiral_defaults \n\nfor param, value in defaults.items():\n    print(f'{param:&lt;10}: {value}')\n</pre> # Get the default settings for the spiral plot defaults = plotter.settings.spiral_defaults   for param, value in defaults.items():     print(f'{param:&lt;10}: {value}')  <pre>bottom    : 30\nlinewidth : 2\nedgecolor : white\n</pre> In\u00a0[10]: Copied! <pre># Get the default settings for the cloud plot\ndefaults = plotter.settings.cloud_defaults\n\n# Print each parameter \nfor param, value in defaults.items():\n    if param != 'mask':\n        print(f'{param:&lt;20}: {value}')\n    else:\n        # But mask it's a large numpy array\n        print(f'{param:&lt;20}: a numpy array (too long to show)')\n</pre> # Get the default settings for the cloud plot defaults = plotter.settings.cloud_defaults  # Print each parameter  for param, value in defaults.items():     if param != 'mask':         print(f'{param:&lt;20}: {value}')     else:         # But mask it's a large numpy array         print(f'{param:&lt;20}: a numpy array (too long to show)') <pre>background_color    : None\nmode                : RGBA\nmask                : a numpy array (too long to show)\nfont_path           : None\nwidth               : 1000\nheight              : 1000\nmax_words           : 200\nprefer_horizontal   : 0.75\nrepeat              : True\nmax_font_size       : 100\ncolormap            : None\n</pre> In\u00a0[11]: Copied! <pre># Modify the default settings \nplotter.settings.spiral_defaults = dict(facecolor='cyan', linewidth=5)\n\n# Check the updated default settings\ndefaults = plotter.settings.spiral_defaults\n\nfor param, value in defaults.items():\n    print(f'{param:&lt;10}: {value}')\n</pre> # Modify the default settings  plotter.settings.spiral_defaults = dict(facecolor='cyan', linewidth=5)  # Check the updated default settings defaults = plotter.settings.spiral_defaults  for param, value in defaults.items():     print(f'{param:&lt;10}: {value}') <pre>bottom    : 30\nlinewidth : 5\nedgecolor : white\nfacecolor : cyan\n</pre> In\u00a0[12]: Copied! <pre>_ = plotter.spiral_frequencies()\n</pre> _ = plotter.spiral_frequencies() <p>Explicitly passing a <code>**kwargs</code> argument at call time takes precedence over the defaults!</p> In\u00a0[13]: Copied! <pre># Bars will be orange and not cyan as specified in the defaults!\n_ = plotter.spiral_frequencies(facecolor='orange')\n</pre> # Bars will be orange and not cyan as specified in the defaults! _ = plotter.spiral_frequencies(facecolor='orange')"},{"location":"Examples/CustomBasic/#working-with-returned-values","title":"Working with Returned Values\u00b6","text":"<p>The methods spiral_frequencies, cloud_frequencies and plot return the matplotlib figure and axes, which can be adjusted after the creation of the plot.</p> <p>In addition, for spiral plots, the bars and text objects relating to the labels of the bars are returned.</p> <p>Let's add a title and change the color of the labels of the bars for a Spiral plot.</p>"},{"location":"Examples/CustomBasic/#keyword-arguments-kwargs","title":"Keyword Arguments (<code>**kwargs</code>)\u00b6","text":""},{"location":"Examples/CustomBasic/#spiral-kwargs","title":"Spiral - kwargs\u00b6","text":"<p>For the spiral plot, you can pass additional keyword arguments to the Matplotlib bar plot. For more information on the allowed kwargs, see Axes.bar.</p> <p>Let's pass <code>facecolor='red'</code> to modify the color of the bars.</p>"},{"location":"Examples/CustomBasic/#cloud-kwargs","title":"Cloud - kwargs\u00b6","text":"<p>For the cloud plot, you can pass additional keyword arguments required for the creation of the <code>WordCloud</code> object. For more information on the allowed kwargs, see WordCloud.</p> <p>For instance, let's use a different colormap.</p>"},{"location":"Examples/CustomBasic/#adjusting-settings","title":"Adjusting Settings\u00b6","text":"<p>Settings control default values and parameters affecting the plots.</p>"},{"location":"Examples/CustomBasic/#fonts","title":"Fonts\u00b6","text":"<p>Changing the fonts through settings will affect the font of any new plot, even for plots using the Matplotlib API directly.</p> <p>Let's change the font. If your computer has the font Impact, you can try the following:</p>"},{"location":"Examples/CustomBasic/#default-values","title":"Default Values\u00b6","text":"<p>In settings, the default values to pass to the <code>**kwargs</code> arguments in the methods spiral_frequencies, cloud_frequencies, and plot are also stored.</p>"},{"location":"Examples/CustomBasic/#spiral-defaults","title":"Spiral Defaults\u00b6","text":""},{"location":"Examples/CustomBasic/#cloud-defaults","title":"Cloud defaults\u00b6","text":""},{"location":"Examples/CustomBasic/#modifying-default-settings","title":"Modifying Default Settings\u00b6","text":"<p>You can add or modify default values. Just ensure that the arguments are accepted by the bar plot method in matplotlib (for the Spiral defaults) or by the WordCloud object (for the Cloud defaults).</p> <p>As an example, let's add the <code>facecolor</code> and change the <code>linewidth</code> of the bars.</p>"},{"location":"Examples/Data/","title":"Data","text":"<p>For this demo, let's use the toy examples from the SandBonx folder that has some dummy scripts.</p> <p>Import the DataPlotter class.</p> In\u00a0[1]: Copied! <pre>from ScanPyImports.plotter import DataPlotter\n</pre> from ScanPyImports.plotter import DataPlotter In\u00a0[2]: Copied! <pre>from ScanPyImports.plotter import DataPlotter\nplotter = DataPlotter('../SandBox') # Set path to the SandBox folder on your computer.\ndf = plotter.df \n\nprint('Number of imports found:', len(df))\nprint('Packages:', df.imported_0.unique().tolist())\ndf.head(len(df))\n</pre> from ScanPyImports.plotter import DataPlotter plotter = DataPlotter('../SandBox') # Set path to the SandBox folder on your computer. df = plotter.df   print('Number of imports found:', len(df)) print('Packages:', df.imported_0.unique().tolist()) df.head(len(df)) <pre>Number of imports found: 10\nPackages: ['sys', 'os', 'math', 'my_scripts', 'matplotlib', 'module1', 're', 'numpy']\n</pre> Out[2]: imported_0 imported_1 alias directory extension file filename original path 0 sys NaN ../SandBox py module1.py module1 import sys, os ../SandBox\\module1.py 1 os NaN ../SandBox py module1.py module1 import sys, os ../SandBox\\module1.py 2 math NaN ../SandBox py module1.py module1 import math ../SandBox\\module1.py 3 my_scripts lookup_dir look ../SandBox py module2.py module2 from my_scripts import lookup_dir as look ../SandBox\\module2.py 4 matplotlib pyplot plt ../SandBox py module2.py module2 import matplotlib.pyplot as plt ../SandBox\\module2.py 5 module1 Class_1 ../SandBox py module2.py module2 from module1 import Class_1 ../SandBox\\module2.py 6 sys NaN ../SandBox\\folder_1 py module3.py module3 import sys, os ../SandBox\\folder_1\\module3.py 7 os NaN ../SandBox\\folder_1 py module3.py module3 import sys, os ../SandBox\\folder_1\\module3.py 8 re NaN ../SandBox\\folder_1 py module3.py module3 import re ../SandBox\\folder_1\\module3.py 9 numpy NaN np ../SandBox\\folder_1 py module3.py module3 import numpy as np ../SandBox\\folder_1\\module3.py <p>For a brief description of the columns in the DataFrame, see DataPlotter.df.</p> <p>In this example:</p> <ul> <li>module1 is a own-created module, which is a <code>py</code> script being imported by another script (<code>module2</code>) located in the same directory.</li> <li>All other packages are external packages.</li> </ul> In\u00a0[3]: Copied! <pre>plotter.get_frequencies()\n</pre> plotter.get_frequencies()   Out[3]: <pre>Imports\nos            3\nsys           3\nmath          2\nmatplotlib    1\nmy_scripts    1\nnumpy         1\nre            1\ndtype: int64</pre> In\u00a0[4]: Copied! <pre>plotter.get_frequencies(process_own_modules=False)\n</pre> plotter.get_frequencies(process_own_modules=False) Out[4]: <pre>Imports\nos            2\nsys           2\nmath          1\nmatplotlib    1\nmodule1       1\nmy_scripts    1\nnumpy         1\nre            1\ndtype: int64</pre> In\u00a0[5]: Copied! <pre>plotter.to_exclude = ['my_scripts']\n</pre> plotter.to_exclude = ['my_scripts'] <p>By default, the <code>get_frequencies()</code> method excludes the packages listed in <code>to_exclude</code> when calculating the frequencies.</p> <p>Thus, <code>my_scripts</code> will not be listed in the code below.</p> In\u00a0[6]: Copied! <pre>plotter.get_frequencies()\n</pre> plotter.get_frequencies() Out[6]: <pre>Imports\nos            3\nsys           3\nmath          2\nmatplotlib    1\nnumpy         1\nre            1\ndtype: int64</pre> <p>If you wish to include them back in your analysis, set the <code>exclude</code> argument to <code>False</code>.</p> In\u00a0[7]: Copied! <pre>plotter.get_frequencies(exclude=False)\n</pre> plotter.get_frequencies(exclude=False) Out[7]: <pre>Imports\nos            3\nsys           3\nmath          2\nmatplotlib    1\nmy_scripts    1\nnumpy         1\nre            1\ndtype: int64</pre>"},{"location":"Examples/Data/#dataframe-of-imported-modules","title":"DataFrame of imported modules\u00b6","text":"<p>The df attribute in the Data, DataAnalyzer, and DataPlotter classes retrieves the unprocessed data from the import statements in the dummy scripts (DataPlotter.df).</p>"},{"location":"Examples/Data/#frequencies","title":"Frequencies\u00b6","text":"<p>To get the frequencies of the packages being imported, one can call the get_frequencies() function in the DataAnalyzer or DataPlotter class (DataPlotter.get_frequencies()).</p>"},{"location":"Examples/Data/#the-process_own_modules-parameter","title":"The <code>process_own_modules</code> parameter\u00b6","text":"<p>By default own-created modules are processed. For more information on how own-created modules are processed, see <code>own_processed_df</code>.</p> <p>For getting the frequencies without processing own-created modules, set the argument <code>process_own_modules</code> to <code>False</code></p>"},{"location":"Examples/Data/#the-exclude-parameter","title":"The <code>exclude</code> parameter\u00b6","text":"<p>To exclude some modules from the frequency analysis, you can assign a list of package names to the <code>to_exclude</code> attribute.</p>"},{"location":"Examples/Example/","title":"More Complex Visualizations","text":"<p>Tutorial: Creating More Complex Visualizations with ScanPyImports</p> <p>Here's an example showcasing the packages I frequently use in my projects. I'm sharing it to provide ideas on how to create more complex visualizations using <code>ScanPyImports</code>,  <code>Matplotlib</code> and <code>WordCloud</code>.</p> <p>Feel free to customize these visualizations to suit your needs and apply the code to your own projects.</p> In\u00a0[1]: Copied! <pre>from ScanPyImports.plotter import DataPlotter\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.patches import FancyBboxPatch\nimport math\nimport random\nimport warnings\n\n# Ignore warnings for clean output\nwarnings.filterwarnings(\"ignore\")\n</pre> from ScanPyImports.plotter import DataPlotter import matplotlib.pyplot as plt from matplotlib.colors import to_rgb from matplotlib.patches import FancyBboxPatch import math import random import warnings  # Ignore warnings for clean output warnings.filterwarnings(\"ignore\") In\u00a0[2]: Copied! <pre># Constants for styling\nROUNDING = 0.1\nBOXSTYLE_BG = f'round, pad=0.01, rounding_size={ROUNDING}'\n\n# Add custom background to a plot (Axes)\ndef box_bg(ax, color):\n    box = FancyBboxPatch((0, 0), 1, 1, boxstyle=BOXSTYLE_BG,\n                          ec='none', fc=color, clip_on=False, transform=ax.transAxes, zorder=0)\n    ax.add_patch(box)\n\n# Define a color palette\ndef tab20() -&gt; dict[str, tuple]: \n    \"\"\"Tableau 20 colors hex codes. \n\n    Returns:\n        Dictionary {color name: (dark, light)}\n    \"\"\"\n    colors = {\n        'blue': ('#1f77b4', '#aec7e8'),\n        'orange': ('#ff7f0e', '#ffbb78'),\n        'green': ('#2ca02c', '#98df8a'),\n        'red': ('#d62728', '#ff9896'),\n        'purple': ('#9467bd', '#c5b0d5'),\n        'brown': ('#8c564b', '#c49c94'),\n        'pink': ('#e377c2', '#f7b6d2'),\n        'gray': ('#7f7f7f', '#c7c7c7'),\n        'olive': ('#bcbd22', '#dbdb8d'),\n        'cyan': ('#17becf', '#9edae5')\n    }\n    return colors\n\n\n# Generate the colors to be used for the words in the Cloud plot\ndef words_colors():\n    \"\"\"Colors in format `rgb(r, g, b)` as required by the WordCloud object.\"\"\"\n    colors = tab20()\n    light_colors = [to_rgb(val[1]) for _, val in colors.items()]\n    light_colors += [(1.0,) * 3] * 10  # Fill with more whites\n    RGB = lambda x: math.floor(x * 255)\n    colorsRGB = [f'rgb{(RGB(a), RGB(b), RGB(c))}' for a, b, c in light_colors]\n    return colorsRGB\n\n# Function to randomly choose a color for the Cloud plot\ndef color_func(*args, **kwargs):\n    \"\"\"Function to be passed as `**kargs` of the Cloud plot.\n    \n    It follows the requirements of the WordCloud Api.\"\"\"\n    colors = words_colors()\n    return random.choice(colors)\n</pre> # Constants for styling ROUNDING = 0.1 BOXSTYLE_BG = f'round, pad=0.01, rounding_size={ROUNDING}'  # Add custom background to a plot (Axes) def box_bg(ax, color):     box = FancyBboxPatch((0, 0), 1, 1, boxstyle=BOXSTYLE_BG,                           ec='none', fc=color, clip_on=False, transform=ax.transAxes, zorder=0)     ax.add_patch(box)  # Define a color palette def tab20() -&gt; dict[str, tuple]:      \"\"\"Tableau 20 colors hex codes.       Returns:         Dictionary {color name: (dark, light)}     \"\"\"     colors = {         'blue': ('#1f77b4', '#aec7e8'),         'orange': ('#ff7f0e', '#ffbb78'),         'green': ('#2ca02c', '#98df8a'),         'red': ('#d62728', '#ff9896'),         'purple': ('#9467bd', '#c5b0d5'),         'brown': ('#8c564b', '#c49c94'),         'pink': ('#e377c2', '#f7b6d2'),         'gray': ('#7f7f7f', '#c7c7c7'),         'olive': ('#bcbd22', '#dbdb8d'),         'cyan': ('#17becf', '#9edae5')     }     return colors   # Generate the colors to be used for the words in the Cloud plot def words_colors():     \"\"\"Colors in format `rgb(r, g, b)` as required by the WordCloud object.\"\"\"     colors = tab20()     light_colors = [to_rgb(val[1]) for _, val in colors.items()]     light_colors += [(1.0,) * 3] * 10  # Fill with more whites     RGB = lambda x: math.floor(x * 255)     colorsRGB = [f'rgb{(RGB(a), RGB(b), RGB(c))}' for a, b, c in light_colors]     return colorsRGB  # Function to randomly choose a color for the Cloud plot def color_func(*args, **kwargs):     \"\"\"Function to be passed as `**kargs` of the Cloud plot.          It follows the requirements of the WordCloud Api.\"\"\"     colors = words_colors()     return random.choice(colors) In\u00a0[3]: Copied! <pre>def fancy_spiral(plot, ax, fg_color, bg_color, title_text= None,  fontname='Arial Rounded MT Bold'):\n    # Create a spiral plot\n    kwargs = dict(edgecolor=bg_color, facecolor=fg_color)\n    _, ax, _, texts = plot.spiral_frequencies(top=25,\n                                              label_padding=5,\n                                              ax=ax,\n                                              **kwargs)\n    \n    # Adjust the properties of the bar labels\n    for text in texts:\n        text.set_fontsize('x-large')\n        text.set_color(fg_color)\n        text.set_font(fontname)\n\n    # Set the title properties\n    if title_text:\n        ax.set_title(title_text\n                        , y = 0.9, x = 0.1\n                        , ha = 'left', va = 'top'\n                        , color = bg_color\n                        , fontsize = 'x-large'\n                        , fontweight = 'bold'\n                        , fontname = fontname\n                        , bbox = dict(facecolor=fg_color # Background color of the title box\n                                    , edgecolor='none'\n                                    , boxstyle='round,pad=1') \n                        )\n\n    # Add a background round box to the plot\n    box_bg(ax, bg_color)\n    \n    return  ax, texts\n</pre> def fancy_spiral(plot, ax, fg_color, bg_color, title_text= None,  fontname='Arial Rounded MT Bold'):     # Create a spiral plot     kwargs = dict(edgecolor=bg_color, facecolor=fg_color)     _, ax, _, texts = plot.spiral_frequencies(top=25,                                               label_padding=5,                                               ax=ax,                                               **kwargs)          # Adjust the properties of the bar labels     for text in texts:         text.set_fontsize('x-large')         text.set_color(fg_color)         text.set_font(fontname)      # Set the title properties     if title_text:         ax.set_title(title_text                         , y = 0.9, x = 0.1                         , ha = 'left', va = 'top'                         , color = bg_color                         , fontsize = 'x-large'                         , fontweight = 'bold'                         , fontname = fontname                         , bbox = dict(facecolor=fg_color # Background color of the title box                                     , edgecolor='none'                                     , boxstyle='round,pad=1')                          )      # Add a background round box to the plot     box_bg(ax, bg_color)          return  ax, texts In\u00a0[4]: Copied! <pre>def fancy_cloud(plot, ax, bg_color, fontname='Impact'):\n\n    # Add box background\n    box_bg(ax, bg_color) # Has to be added first!\n\n    # Set the font if provided\n    if fontname:\n        plot.settings.set_font(fontname)\n\n    # Define `**kwargs` parameters for the cloud plot\n    kwargs = dict(color_func=color_func, max_words=200)\n\n    # Define the `imshow` parameter.\n    # Here we ajust the size of the image to get some space \n    #   between the image and axis\n    shrink = 0.10\n    imshow = dict(extent=(0 + shrink, 1 - shrink, 0 + shrink, 1 - shrink),\n                  transform=ax.transAxes)\n\n    # Generate the cloud plot\n    _, ax, wc, _ = plot.cloud_frequencies(ax=ax, imshow=imshow, **kwargs)\n    return ax, wc\n</pre> def fancy_cloud(plot, ax, bg_color, fontname='Impact'):      # Add box background     box_bg(ax, bg_color) # Has to be added first!      # Set the font if provided     if fontname:         plot.settings.set_font(fontname)      # Define `**kwargs` parameters for the cloud plot     kwargs = dict(color_func=color_func, max_words=200)      # Define the `imshow` parameter.     # Here we ajust the size of the image to get some space      #   between the image and axis     shrink = 0.10     imshow = dict(extent=(0 + shrink, 1 - shrink, 0 + shrink, 1 - shrink),                   transform=ax.transAxes)      # Generate the cloud plot     _, ax, wc, _ = plot.cloud_frequencies(ax=ax, imshow=imshow, **kwargs)     return ax, wc In\u00a0[5]: Copied! <pre># Define the projects to analyze\n# These are my project directories, but you can provide your own directories and projects names!\nprojects = {\n'@Graz' : DataPlotter(r\"D:\\Dropbox\\Research\\DigitalComp\"),\n'@WU' : DataPlotter(r'D:\\Dropbox\\Research\\MigrationAT'),\n'All' : DataPlotter(r'D:\\Dropbox')\n}\n\n# Exclude specific packages by setting the `to_exclude` attribute\nto_exclude = ['my_scripts', 'my_package', 'my_plots', 'my_module', 'my_sum']\nfor  plotter in projects.values():\n    plotter.to_exclude = to_exclude\n</pre> # Define the projects to analyze # These are my project directories, but you can provide your own directories and projects names! projects = { '@Graz' : DataPlotter(r\"D:\\Dropbox\\Research\\DigitalComp\"), '@WU' : DataPlotter(r'D:\\Dropbox\\Research\\MigrationAT'), 'All' : DataPlotter(r'D:\\Dropbox') }  # Exclude specific packages by setting the `to_exclude` attribute to_exclude = ['my_scripts', 'my_package', 'my_plots', 'my_module', 'my_sum'] for  plotter in projects.values():     plotter.to_exclude = to_exclude In\u00a0[6]: Copied! <pre># Define subplot configuration\n# Note: The projection for spiral plots must be 'polar'\nper_subplot_kw = {key: {'projection': 'polar'} for key in projects.keys()}\n\n# Set up the figure and axes\nsize = 4.5\nfig, axs = plt.subplot_mosaic([['@WU', '@Graz'],\n    ['cloud', 'All']], \n    per_subplot_kw=per_subplot_kw, \n    figsize=(size * 2, size * 2), \n    gridspec_kw={\n        \"bottom\": 0.1,\n        \"top\": 0.9,\n        \"left\": 0.1,\n        \"right\": 0.9,\n        \"wspace\": 0.1 * 2 / 3,\n        \"hspace\": 0.1 * 2 / 3\n    }\n)\n\n# Define colors\ncolors = tab20()\n\n# Create cloud plot for the project 'All' \nbg_color = colors['blue'][0]\naxs['cloud'], wc= fancy_cloud(projects['All'], ax=axs['cloud'],bg_color=bg_color)\n\n# Create spiral plots for each project\nfg_color = 'white'\nbg_colors = ['gray', 'orange', 'red']\nfor (project, plot), color  in zip(projects.items(),bg_colors):\n    bg_color = colors[color][0]\n    axs[project], texts = fancy_spiral(plot, axs[project]\n                                , fg_color, bg_color\n                                , title_text=project)\n    # Manually adjust labels that go out of the plot (`All` spiral) \n    if project == 'All':\n        for text in texts[-4:]:\n            text.set_horizontalalignment('right') \n            x,y = text.get_position()\n            text.set_position((x,y-10))\n            text.set_color(bg_color)\n</pre> # Define subplot configuration # Note: The projection for spiral plots must be 'polar' per_subplot_kw = {key: {'projection': 'polar'} for key in projects.keys()}  # Set up the figure and axes size = 4.5 fig, axs = plt.subplot_mosaic([['@WU', '@Graz'],     ['cloud', 'All']],      per_subplot_kw=per_subplot_kw,      figsize=(size * 2, size * 2),      gridspec_kw={         \"bottom\": 0.1,         \"top\": 0.9,         \"left\": 0.1,         \"right\": 0.9,         \"wspace\": 0.1 * 2 / 3,         \"hspace\": 0.1 * 2 / 3     } )  # Define colors colors = tab20()  # Create cloud plot for the project 'All'  bg_color = colors['blue'][0] axs['cloud'], wc= fancy_cloud(projects['All'], ax=axs['cloud'],bg_color=bg_color)  # Create spiral plots for each project fg_color = 'white' bg_colors = ['gray', 'orange', 'red'] for (project, plot), color  in zip(projects.items(),bg_colors):     bg_color = colors[color][0]     axs[project], texts = fancy_spiral(plot, axs[project]                                 , fg_color, bg_color                                 , title_text=project)     # Manually adjust labels that go out of the plot (`All` spiral)      if project == 'All':         for text in texts[-4:]:             text.set_horizontalalignment('right')              x,y = text.get_position()             text.set_position((x,y-10))             text.set_color(bg_color)"},{"location":"Examples/Example/#importing-libraries","title":"Importing Libraries\u00b6","text":""},{"location":"Examples/Example/#setting-up-constants-and-utility-functions","title":"Setting Up Constants and Utility Functions\u00b6","text":"<p>Next, we define some constants and utility functions that will help us in creating the visualizations.</p>"},{"location":"Examples/Example/#fancy-spiral-plot-function","title":"Fancy Spiral Plot Function\u00b6","text":"<p>We define a function <code>fancy_spiral</code> to create a spiral plot with custom foreground and background colors.</p>"},{"location":"Examples/Example/#fancy-cloud-plot-function","title":"Fancy Cloud Plot Function\u00b6","text":""},{"location":"Examples/Example/#setting-up-projects-and-dataplotters","title":"Setting Up Projects and DataPlotters\u00b6","text":"<p>We initialize a DataPlotter object per project (directories).</p>"},{"location":"Examples/Example/#creating-the-visualization","title":"Creating the Visualization\u00b6","text":"<p>Finally, we create a mosaic plot with different subplots for each project.</p>"},{"location":"Examples/Masks/","title":"Masks for Cloud plots","text":"<p>Import modules and setup font.</p> In\u00a0[1]: Copied! <pre>import os\nfrom ScanPyImports.plotter import DataPlotter, mask_from_path, get_fontname_list\n</pre> import os from ScanPyImports.plotter import DataPlotter, mask_from_path, get_fontname_list In\u00a0[2]: Copied! <pre># Initailize DataPlotter with directory\nplotter = DataPlotter('../../ScanPyImports')\n\n# In this example, we use the Impact font\nplotter.settings.set_font('Impact')\n\n# If you are not on Windows, you might not have it.\n# Either skip the previous step or choose another font\nif 'Impact' in get_fontname_list():\n    print('\"Impact\" is installed on your computer')\nelse:\n    print('\"Impact\" is not installed!')\n    print('Use `get_fontname_list()` to check which fonts are installed on your computer.')\n</pre> # Initailize DataPlotter with directory plotter = DataPlotter('../../ScanPyImports')  # In this example, we use the Impact font plotter.settings.set_font('Impact')  # If you are not on Windows, you might not have it. # Either skip the previous step or choose another font if 'Impact' in get_fontname_list():     print('\"Impact\" is installed on your computer') else:     print('\"Impact\" is not installed!')     print('Use `get_fontname_list()` to check which fonts are installed on your computer.')  <pre>\"Impact\" is installed on your computer\n</pre> <p>You can use any <code>png</code> image as a mask for the WordCloud plot.</p> <p>Here is an example with an image included in the package. You can use your own image!</p> In\u00a0[3]: Copied! <pre># File with the image to use as a mask\npath = r'../../ScanPyImports/images'\nfile_img = 'star.png'\n\n# Get the mask of the image (np.array)\nmask = mask_from_path(os.path.join(path, file_img))\n\n# Plot\nfig, ax, *_ = plotter.cloud_frequencies(mask=mask)\n</pre> # File with the image to use as a mask path = r'../../ScanPyImports/images' file_img = 'star.png'  # Get the mask of the image (np.array) mask = mask_from_path(os.path.join(path, file_img))  # Plot fig, ax, *_ = plotter.cloud_frequencies(mask=mask)  <p>In the image folder of the package, you can find other images to use as masks.</p> <p>Here is a showcase of the available images.</p> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\n\n# Helper function to get the mask from the file image\nmask = lambda file_img: mask_from_path(os.path.join(path, file_img))\n\n# Set the size for the plots\nsize = 3\n\n# Create a mosaic of subplots for each shape/mask\nfig, axs = plt.subplot_mosaic(\n    [['default', 'star'], ['circle', 'triangle']],\n    figsize=(size * 2, size * 2),\n    layout='constrained'\n)\n\n# Default shape plot\nfig, axs['default'], *_ = plotter.cloud_frequencies(ax=axs['default'])\n\n# Plot for other shapes\nfor shape in ['star', 'circle', 'triangle']:\n    fig, axs[shape], *_=plotter.cloud_frequencies(ax=axs[shape]\n                                                  , mask=mask(f'{shape}.png')\n                                                  )\n</pre> import matplotlib.pyplot as plt  # Helper function to get the mask from the file image mask = lambda file_img: mask_from_path(os.path.join(path, file_img))  # Set the size for the plots size = 3  # Create a mosaic of subplots for each shape/mask fig, axs = plt.subplot_mosaic(     [['default', 'star'], ['circle', 'triangle']],     figsize=(size * 2, size * 2),     layout='constrained' )  # Default shape plot fig, axs['default'], *_ = plotter.cloud_frequencies(ax=axs['default'])  # Plot for other shapes for shape in ['star', 'circle', 'triangle']:     fig, axs[shape], *_=plotter.cloud_frequencies(ax=axs[shape]                                                   , mask=mask(f'{shape}.png')                                                   )"},{"location":"Examples/Plots/","title":"Visualizing Any Data","text":"<p>The spiral_frequencies and cloud_frequencies methods utilize the Spiral and Cloud classes, respectively. You can use these classes to plot any data.</p> <p>As an example, let's use data on the most-spoken first languages from the CIA World Factbook.</p> In\u00a0[1]: Copied! <pre>data = {'Mandarin Chinese': 12.3, 'Spanish': 6.0, 'English': 5.1, 'Arabic': 5.1, 'Hindi': 3.5, 'Bengali': 3.3, 'Portuguese': 3.0, 'Russian': 2.1, 'Japanese': 1.7, 'Punjabi Western': 1.3, 'Javanese': 1.1}\n</pre> data = {'Mandarin Chinese': 12.3, 'Spanish': 6.0, 'English': 5.1, 'Arabic': 5.1, 'Hindi': 3.5, 'Bengali': 3.3, 'Portuguese': 3.0, 'Russian': 2.1, 'Japanese': 1.7, 'Punjabi Western': 1.3, 'Javanese': 1.1} <p>To create a spiral plot, use the plot method.</p> In\u00a0[2]: Copied! <pre>from ScanPyImports.plotter import Spiral\n\nspiral=Spiral() \n# Prepare the data \n# = &gt; Sort by ascending order\ndata = dict(sorted(data.items(), key=lambda item: item[1]))\nlabels = data.keys()\nvalues = data.values()\n\nfig, ax, bars, texts = spiral.plot(labels,values)\n</pre> from ScanPyImports.plotter import Spiral  spiral=Spiral()  # Prepare the data  # = &gt; Sort by ascending order data = dict(sorted(data.items(), key=lambda item: item[1])) labels = data.keys() values = data.values()  fig, ax, bars, texts = spiral.plot(labels,values) <p>To create a cloud plot, use the plot method.</p> In\u00a0[3]: Copied! <pre>from ScanPyImports.plotter import Cloud \ncloud = Cloud()\nfig, ax, wc, im = cloud.plot(data)\n</pre> from ScanPyImports.plotter import Cloud  cloud = Cloud() fig, ax, wc, im = cloud.plot(data)"},{"location":"Examples/Plots/#spiral","title":"Spiral\u00b6","text":""},{"location":"Examples/Plots/#cloud","title":"Cloud\u00b6","text":""},{"location":"Examples/PlotsImports/","title":"Visualizing Imported Modules","text":"<p>For this demo, let's analyze the modules imported by this package - ScanPyImports.</p> <p>Import the DataPlotter class.</p> In\u00a0[1]: Copied! <pre>from ScanPyImports.plotter import DataPlotter\n</pre> from ScanPyImports.plotter import DataPlotter <p>Let's inspect first the frequencies of imported modules by the ScanPyImports package.</p> In\u00a0[2]: Copied! <pre>plotter = DataPlotter('../../ScanPyImports')\nplotter.get_frequencies()\n</pre> plotter = DataPlotter('../../ScanPyImports') plotter.get_frequencies() Out[2]: <pre>Imports\ntyping           14\nmatplotlib        8\nScanPyImports     4\nos                3\nPIL               1\nnbformat          1\nnumpy             1\npandas            1\nre                1\nwordcloud         1\ndtype: int64</pre> In\u00a0[3]: Copied! <pre>fig, ax, bars, texts = plotter.spiral_frequencies()\n</pre> fig, ax, bars, texts = plotter.spiral_frequencies() In\u00a0[4]: Copied! <pre>fig, ax, wc, im = plotter.cloud_frequencies()\n</pre> fig, ax, wc, im = plotter.cloud_frequencies() In\u00a0[5]: Copied! <pre>import matplotlib.pyplot as plt\n\nsize = 10\nfig, axs = plt.subplot_mosaic(\n    [[\"defaults\", 'zero_at'], ['top', 'label_padding']],\n    figsize=(size, size),\n    subplot_kw = dict(projection = 'polar'),\n    layout='constrained'\n)\n\nparameters = \"defaults\", 'zero_at' , 'top', 'label_padding'\nvalues = False, 'SW', 3, 10\n\nfor p,val in zip(parameters, values) :\n    parms={p:val}\n    fig, axs[p], *_=plotter.spiral_frequencies(ax=axs[p], **parms) \n    title = axs[p].set_title(f'{p}={val}'\n                             , bbox=dict(boxstyle='round'\n                             , edgecolor='cyan'\n                             , facecolor='cyan'\n                             )\n                            )\n</pre> import matplotlib.pyplot as plt  size = 10 fig, axs = plt.subplot_mosaic(     [[\"defaults\", 'zero_at'], ['top', 'label_padding']],     figsize=(size, size),     subplot_kw = dict(projection = 'polar'),     layout='constrained' )  parameters = \"defaults\", 'zero_at' , 'top', 'label_padding' values = False, 'SW', 3, 10  for p,val in zip(parameters, values) :     parms={p:val}     fig, axs[p], *_=plotter.spiral_frequencies(ax=axs[p], **parms)      title = axs[p].set_title(f'{p}={val}'                              , bbox=dict(boxstyle='round'                              , edgecolor='cyan'                              , facecolor='cyan'                              )                             )   In\u00a0[6]: Copied! <pre>_ = plotter.cloud_frequencies(defaults=False)\n</pre> _ = plotter.cloud_frequencies(defaults=False) <p>Modifying the <code>imshow</code> parameter.</p> In\u00a0[7]: Copied! <pre>_ = plotter.cloud_frequencies(imshow=dict(alpha=0.3))\n</pre> _ = plotter.cloud_frequencies(imshow=dict(alpha=0.3))"},{"location":"Examples/PlotsImports/#spiral-plot","title":"Spiral plot\u00b6","text":""},{"location":"Examples/PlotsImports/#wordcloud-plot","title":"WordCloud plot\u00b6","text":""},{"location":"Examples/PlotsImports/#parameters","title":"Parameters\u00b6","text":"<p>The <code>spiral_frequencies()</code> and <code>cloud_frequencies()</code> methods have three types of parameters:</p> <ol> <li>Parameters relating to the data processing of the imported modules:<ul> <li>The <code>exclude</code> and <code>process_own_modules</code> parameters, explained in Data.</li> </ul> </li> <li>Parameters passed as an argument to external APIs:<ul> <li>The <code>**kwargs</code> parameters explained in this tutorial.</li> <li>In particular:<ul> <li>Spiral plots call the bar plot method from Matplotlib.</li> <li>Cloud plots are instances of the WordCloud class.</li> </ul> </li> </ul> </li> <li>Parameters relating to visualization options of the plots implemented in this package:<ul> <li>These are showcased below.</li> </ul> </li> </ol>"},{"location":"Examples/PlotsImports/#spiral-parameters","title":"Spiral Parameters\u00b6","text":"<p>Signature:</p> <ul> <li>spiral_frequencies(exclude=True, process_own_modules=True, top=25, ax=None, zero_at='NE', defaults=True, label_padding=2, **kwargs)</li> </ul> <p>Let's showcase some paramterers changes.</p>"},{"location":"Examples/PlotsImports/#cloud-parameters","title":"Cloud Parameters\u00b6","text":"<p>Signature:</p> <ul> <li>cloud_frequencies(exclude=True, process_own_modules=True, defaults=True, ax=None, imshow=None, **kwargs)</li> </ul> <p>Setting <code>defaults</code> to <code>False</code>.</p>"},{"location":"Examples/demos_index/","title":"Demos, Tutorials","text":"<ul> <li> <p>Data</p> <ul> <li>Data         Getting the DataFrame of your imported modules.</li> </ul> </li> <li> <p>Vizualization</p> <ul> <li>Visualizing Imported Modules</li> <li>Visualizing Any Data</li> </ul> </li> <li> <p>Viz. Customization</p> <ul> <li>Basics</li> <li>Masks for Cloud plots</li> <li>More Complex Visualizations </li> </ul> </li> </ul>"}]}